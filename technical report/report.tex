\documentclass[a4paper]{article}

\include{packages}

\newtheorem{theorem}{Theorem}[section]
\newtheorem{lemma}{Lemma}[section]
\newtheorem{corollary}{Corollary}[theorem]

\begin{document}

\title{Gradual Intersection Types}

\author{Pedro Ângelo, Mário Florido}

\maketitle
\pagenumbering{arabic}

\section{Language Definition}
\begin{figure}[H]
Syntax
\begin{align*}
&Types\ \begin{aligned}[t] T &::=\ \Int\ |\ \Bool\ |\ T \rightarrow T\ |\ T \cap \ldots \cap T \end{aligned}\\
&Expressions\ \begin{aligned}[t] e\ ::=&\ x\ |\ \lambda x : T\ .\ e\ |\ e\ e\ |\ n\ |\ \true\ |\ \false \end{aligned}
\end{align*}

\framebox[1.2\width]{$\Gamma \sits e : T$}\ Typing
\begin{mathpar}
\inferrule* [right=T-Var]
{x : T \in \Gamma}
{\Gamma \sits x : T}

\inferrule* [right=T-Abs]
{\Gamma, x : T_1 \cap \ldots \cap T_n \sits\ e : T}
{\Gamma \sits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T}

\inferrule* [right=T-Abs']
{\Gamma, x : T_i \sits\ e : T}
{\Gamma \sits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T}

\inferrule* [right=T-App]
{\Gamma \sits e_1 : T_1 \cap \ldots \cap T_n \rightarrow T \\
 \Gamma \sits e_2 : T_1 \cap \ldots \cap T_n}
{\Gamma \sits e_1\ e_2 : T}

\inferrule* [right=T-Gen]
{\Gamma \sits e : T_1\ \ldots\ \Gamma \sits e : T_n}
{\Gamma \sits e : T_1 \cap \ldots \cap T_n}

\inferrule* [right=T-Inst]
{\Gamma \sits e : T_1 \cap \ldots \cap T_n}
{\Gamma \sits e : T_i}

\inferrule* [right=T-Int]
{ }
{\Gamma \sits n : \Int}

\inferrule* [right=T-True]
{ }
{\Gamma \sits \true : \Bool}

\inferrule* [right=T-False]
{ }
{\Gamma \sits \false : \Bool}
\end{mathpar}
\hrulefill
\caption{Static Intersection Type System ($\sits$)}
\label{static_intersection_type_system}
\end{figure}

\begin{figure}[H]
Syntax
\begin{align*}
&Types\ \begin{aligned}[t] T &::=\ \Int\ |\ \Bool\ |\ \Dyn\ |\ T \rightarrow T\ |\ T \cap \ldots \cap T \end{aligned}\\
&Expressions\ \begin{aligned}[t] e\ ::=&\ x\ |\ \lambda x : T\ .\ e\ |\ e\ e\ |\ n\ |\ \true\ |\ \false \end{aligned}
\end{align*}

\framebox[1.2\width]{$\Gamma \gits e : T$}\ Typing
\begin{mathpar}
\inferrule* [right=T-Var]
{x : T \in \Gamma}
{\Gamma \gits x : T}

\inferrule* [right=T-Abs]
{\Gamma, x : T_1 \cap \ldots \cap T_n \gits\ e : T}
{\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T}

\inferrule* [right=T-Abs']
{\Gamma, x : T_i \gits\ e : T}
{\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T}

\inferrule* [right=T-App]
{\Gamma \gits e_1 : PM \\
 PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T \\\\
 \Gamma \gits e_2 : T_1' \cap \ldots \cap T_n' \\
 T_1' \cap \ldots \cap T_n' \sim T_1 \cap \ldots \cap T_n}
{\Gamma \gits e_1\ e_2 : T}

\inferrule* [right=T-Gen]
{\Gamma \gits e : T_1\ \ldots\ \Gamma \gits e : T_n}
{\Gamma \gits e : T_1 \cap \ldots \cap T_n}

\inferrule* [right=T-Inst]
{\Gamma \gits e : T_1 \cap \ldots \cap T_n}
{\Gamma \gits e : T_i}

\inferrule* [right=T-Int]
{ }
{\Gamma \gits n : \Int}

\inferrule* [right=T-True]
{ }
{\Gamma \gits \true : \Bool}

\inferrule* [right=T-False]
{ }
{\Gamma \gits \false : \Bool}
\end{mathpar}

\framebox[1.2\width]{$T \sim T$}\ Consistency
\begin{mathpar}
\inferrule* []
{}
{T \sim T}

\inferrule* []
{}
{T \sim \Dyn}

\inferrule* []
{}
{\Dyn \sim T}

\inferrule* []
{T_1 \sim T_3 \\ T_2 \sim T_4}
{T_1 \rightarrow T_2 \sim T_3 \rightarrow T_4}

\inferrule* []
{T_1 \sim T'_1\ \ldots\ T_n \sim T'_n}
{T_1 \cap \ldots \cap T_n \sim T'_1 \cap \ldots \cap T'_n}
\end{mathpar}

\framebox[1.2\width]{$T \rhd T$}\ Pattern Matching
\begin{mathpar}
\inferrule* []
{}
{T_1 \rightarrow T_2 \rhd T_1 \rightarrow T_2}

\inferrule* []
{}
{\Dyn \rhd \Dyn \rightarrow \Dyn}
\end{mathpar}
\hrulefill
\caption{Gradual Intersection Type System ($\gits$)}
\label{gradual_intersection_type_system}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$T \sqsubseteq T$}\ Type Precision
\begin{mathpar}
\inferrule* []
{}
{\Dyn \sqsubseteq T}

\inferrule* []
{}
{T \sqsubseteq T}

\inferrule* []
{T_1 \sqsubseteq T_3 \\ T_2 \sqsubseteq T_4}
{T_1 \rightarrow T_2 \sqsubseteq T_3 \rightarrow T_4}

\inferrule* []
{T_1 \sqsubseteq T'_1\ \ldots\ T_n \sqsubseteq T'_n}
{T_1 \cap \ldots \cap T_n \sqsubseteq T'_1 \cap \ldots \cap T'_n}

\inferrule* []
{T \sqsubseteq T_1\ \ldots\ T \sqsubseteq T_n}
{T \sqsubseteq T_1 \cap \ldots \cap T_n}

\inferrule* []
{T_1 \sqsubseteq T\ \ldots\ T_n \sqsubseteq T}
{T_1 \cap \ldots \cap T_n \sqsubseteq T}
\end{mathpar}

\framebox[1.2\width]{$c \sqsubseteq c$}\ Cast Precision
\begin{mathpar}
\inferrule* []
{c \sqsubseteq c' \\ T_1 \sqsubseteq T_1' \\ T_2 \sqsubseteq T_2' }
{c : T_1 \Rightarrow^l T_2\ ^{cl} \sqsubseteq c' : T_1' \Rightarrow^{l'} T_2'\ ^{cl'}}

\inferrule* []
{c \sqsubseteq c' \\ \cits c' : T \\ T_1 \sqsubseteq T \\ T_2 \sqsubseteq T }
{c : T_1 \Rightarrow^l T_2\ ^{cl} \sqsubseteq c'}

\inferrule* []
{c \sqsubseteq c' \\ \cits c : T \\ T \sqsubseteq T_1 \\ T \sqsubseteq T_2}
{c \sqsubseteq c' : T_1 \Rightarrow^l T_2\ ^{cl}}

\inferrule* []
{T_I \sqsubseteq T_I' \\ T_F \sqsubseteq T_F'}
{\blamecast{T_I}{T_F}{l}{cl} \sqsubseteq \blamecast{T_I'}{T_F'}{l'}{cl'}}

\inferrule* []
{T \sqsubseteq T'}
{\emptycast{T}{cl} \sqsubseteq \emptycast{T'}{cl'}}
\end{mathpar}

\framebox[1.2\width]{$e \sqsubseteq e$}\ Expression Precision
\begin{mathpar}
\inferrule* []
{}
{x \sqsubseteq x}

\inferrule* []
{T \sqsubseteq T' \\ e \sqsubseteq e'}
{\lambda x : T\ .\ e \sqsubseteq \lambda x : T'\ .\ e'}

\inferrule* []
{e_1 \sqsubseteq e_1' \\ e_2 \sqsubseteq e_2'}
{e_1\ e_2 \sqsubseteq e_1'\ e_2'}

\inferrule* []
{}
{n \sqsubseteq n}

\inferrule* []
{}
{\true \sqsubseteq \true}

\inferrule* []
{}
{\false \sqsubseteq \false}

\inferrule* []
{e \sqsubseteq e' \\ c_1 \sqsubseteq c_1' \ldots c_n \sqsubseteq c_n'}
{e : c_1 \cap \ldots \cap c_n \sqsubseteq e' : c_1' \cap \ldots \cap c_n'}

\inferrule* []
{e \sqsubseteq e' \\ \Gamma \iccts e' : T \\ \cits c_1 : T_1 \ldots \cits c_n : T_n \\ T_1 \cap \ldots \cap T_n \sqsubseteq T}
{e : c_1 \cap \ldots \cap c_n \sqsubseteq e'}

\inferrule* []
{e \sqsubseteq e' \\ \Gamma \iccts e : T \\ \cits c_1 : T_1 \ldots \cits c_n : T_n \\ T \sqsubseteq T_1 \cap \ldots \cap T_n}
{e \sqsubseteq e' : c_1 \cap \ldots \cap c_n}

\inferrule* []
{\Gamma \iccts e : T \\ T \sqsubseteq T'}
{e \sqsubseteq \blame{T'}{l}}
\end{mathpar}
\hrulefill
\caption{Precision ($\sqsubseteq$)}
\label{precision}
\end{figure}

\begin{figure}[H]
Syntax
\begin{align*}
&Types\ \begin{aligned}[t] T &::=\ \Int\ |\ \Bool\ |\ \Dyn\ |\ T \rightarrow T \end{aligned}\\
&Casts\ \begin{aligned}[t] c\ ::=&\ c : T \Rightarrow^l T\ ^{cl}\ |\ \blamecast{T}{T}{l}{cl}\ |\ \emptycast{T}{cl} \end{aligned}
\end{align*}

\framebox[1.2\width]{$\cits c : T$}\ Typing
\begin{mathpar}

\inferrule* [right=T-SingleCI]
{\cits c : T_1 \\ T_1 \sim T_2}
{\cits (c : T_1 \Rightarrow^l T_2\ ^{cl}) : T_2}

\inferrule* [right=T-BlameCI]
{ }
{\cits \blamecast{T_I}{T_F}{l}{cl} : T_F}

\inferrule* [right=T-EmptyCI]
{ }
{\cits \emptycast{T}{cl} : T}
\end{mathpar}

\begin{minipage}[t]{.49\textwidth}
\framebox[1.2\width]{initialType(c) = T}
\begin{mathpar}
\inferrule* []
{}
{initialType(c : T_1 \Rightarrow^l T_2\ ^{cl}) = initialType(c)}\\

\inferrule* []
{}
{initialType(\emptycast{T}{cl}) = T}\\

\inferrule* []
{}
{initialType(\blamecast{T_I}{T_F}{l}{cl}) = T_I}
\end{mathpar}
\end{minipage}
\begin{minipage}[t]{.49\textwidth}
\framebox[1.2\width]{finalType(c) = T}
\begin{mathpar}
\inferrule* []
{}
{finalType(c : T_1 \Rightarrow^l T_2\ ^{cl}) = T_2}\\

\inferrule* []
{}
{finalType(\emptycast{T}{cl}) = T}\\

\inferrule* []
{}
{finalType(\blamecast{T_I}{T_F}{l}{cl}) = T_F}
\end{mathpar}
\end{minipage}
\newline

\hrulefill
\caption{Cast Intersection Type System ($\cits$)}
\label{cast_intersection_type_system}
\end{figure}

\begin{figure}[H]
Syntax
\begin{align*}
&Types\ \begin{aligned}[t] T &::=\ \Int\ |\ \Bool\ |\ \Dyn\ |\ T \rightarrow T\ |\ T \cap \ldots \cap T \end{aligned}\\
&Expressions\ \begin{aligned}[t] e\ ::=&\ x\ |\ \lambda x : T\ .\ e\ |\ e\ e\ |\ n\ |\ \true\ |\ \false\ |\ e : c \cap \ldots \cap c\ |\ \blame{T}{l} \end{aligned}
\end{align*}

\framebox[1.2\width]{$\Gamma \iccts e : T$}\ Typing
\begin{mathpar}
\inferrule* []
{}
{Static\ Intersection\ Type\ System\ ($\sits$)\ rules\ and}\\

\inferrule* [right=T-App']
{\Gamma \iccts e_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2} \\
 \Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}}
{\Gamma \iccts e_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}}

\inferrule* [right=T-CastIntersection]
{\Gamma \iccts e : T_1' \cap \ldots \cap T_n' \\ \cits c_1 : T_1\ \ldots\ \cits c_n : T_n \\\\  T_1' \cap \ldots \cap T_n' = initialType(c_1) \cap \ldots \cap initialType(c_n)}
{\Gamma \iccts e : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n}

\inferrule* [right=T-Blame]
{ }
{\Gamma \iccts \blame{T}{l} : T}
\end{mathpar}
\hrulefill
\caption{Intersection Cast Calculus ($\iccts$)}
\label{intersection_cast_calculus}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$\Gamma \iccts e \leadsto e : T$}\ Compilation
\begin{mathpar}
\inferrule* [right=C-Var]
{x : T \in \Gamma}
{\Gamma \iccts x \leadsto x : T}

\inferrule* [right=C-Abs]
{\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e \leadsto e' : T}
{\Gamma \iccts (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e) \leadsto (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e') : T_1 \cap \ldots \cap T_n \rightarrow T}

\inferrule* [right=C-Abs']
{\Gamma, x : T_i \iccts e \leadsto e' : T}
{\Gamma \iccts (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e) \leadsto (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e') : T_i \rightarrow T}

\inferrule* [right=C-App]
{\Gamma \iccts e_1 \leadsto e_1' : PM \\ PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T \\ \Gamma \iccts e_2 \leadsto e_2' : T'_1 \cap \ldots \cap T'_n \\ T'_1 \cap \ldots \cap T'_n \sim T_1 \cap \ldots \cap T_n \\ PM \trianglelefteq S_1 \\ T_1 \cap \ldots \cap T_n \rightarrow T \trianglelefteq S_2 \\ T'_1 \cap \ldots \cap T'_n \trianglelefteq S_3 \\ T_1 \cap \ldots \cap T_n \trianglelefteq S_4 \\ S_1,\ S_2,\ e_1' \hookrightarrow e_1'' \\ S_3,\ S_4,\ e_2' \hookrightarrow e_2''}
{\Gamma \iccts e_1\ e_2 \leadsto e_1''\ e_2'' : T}

\inferrule* [right=C-Gen]
{\Gamma \iccts e \leadsto e' : T_1\ \ldots\ \Gamma \iccts e \leadsto e' : T_n}
{\Gamma \iccts e \leadsto e': T_1 \cap \ldots \cap T_n}

\inferrule* [right=C-Inst]
{\Gamma \iccts e \leadsto e' : T_1 \cap \ldots \cap T_n}
{\Gamma \iccts e \leadsto e' : T_i}

\inferrule* [right=C-Int]
{ }
{\Gamma \iccts n \leadsto n : \Int}

\inferrule* [right=C-True]
{ }
{\Gamma \iccts \true \leadsto \true : \Bool}

\inferrule* [right=C-False]
{ }
{\Gamma \iccts \false \leadsto \false : \Bool}
\end{mathpar}

\framebox[1.2\width]{T $\trianglelefteq$ \{T\}}\ Instances
\begin{mathpar}
\inferrule* []
{}
{\Int \trianglelefteq \{\Int\}}

\inferrule* []
{}
{\Bool \trianglelefteq \{\Bool\}}

\inferrule* []
{}
{\Dyn \trianglelefteq \{\Dyn\}}\\

\inferrule* []
{T_1 \trianglelefteq \{T_{11}, \ldots, T_{1n}\}}
{T_1 \rightarrow T_2 \trianglelefteq \{T_{11} \rightarrow T_2, \ldots, T_{1n} \rightarrow T_2\}}

\inferrule* []
{T_1 \trianglelefteq \{T_{11}, \ldots, T_{1m}\} \ldots T_n \trianglelefteq \{T_{n1}, \ldots, T_{nj}\}}
{T_1 \cap \ldots \cap T_n \trianglelefteq \{T_{11}, \ldots, T_{1m}, \ldots, T_{n1}, \ldots, T_{nj}\}}
\end{mathpar}

\framebox[1.2\width]{$S,\ S,\ e \hookrightarrow e$}\ Cast Insertion
\begin{mathpar}
\inferrule* []
{}
{\{T_1\},\ \{T_2\},\ e \hookrightarrow e : (\emptycast{T_1}{0} : T_1 \Rightarrow^l T_2\ ^{0})}\\

\inferrule* []
{}
{\{T_{11}, \ldots, T_{1n}\},\ \{T_{21}, \ldots, T_{2n}\},\ e \hookrightarrow e : (\emptycast{T_{11}}{0} : T_{11} \Rightarrow^{l_1} T_{21}\ ^{0}) \cap \ldots \cap (\emptycast{T_{1n}}{0} : T_{1n} \Rightarrow^{l_n} T_{2n}\ ^{0})}\\

\inferrule* []
{}
{\{T_{11}, \ldots, T_{1n}\},\ \{T_2\},\ e \hookrightarrow e : (\emptycast{T_{11}}{0} : T_{11} \Rightarrow^{l_1} T_2\ ^{0}) \cap \ldots \cap (\emptycast{T_{1n}}{0} : T_{1n} \Rightarrow^{l_n} T_2\ ^{0})}\\

\inferrule* []
{}
{\{T_1\},\ \{T_{21}, \ldots, T_{2n}\},\ e \hookrightarrow e : (\emptycast{T_1}{0} : T_1 \Rightarrow^{l_1} T_{21}\ ^{0}) \cap \ldots \cap (\emptycast{T_1}{0} : T_1 \Rightarrow^{l_n} T_{2n}\ ^{0})}
\end{mathpar}
\hrulefill
\caption{Compilation to the Intersection Cast Calculus}
\label{intersection_cast_insertion}
\end{figure}

\begin{figure}[H]
Syntax
\begin{align*}
&Types\ \begin{aligned}[t] T &::=\ \Int\ |\ \Bool\ |\ \Dyn\ |\ T \rightarrow T \end{aligned}\\
&Ground\ Types\ G\ ::=\ \Int\ |\ \Bool\ |\ \Dyn \rightarrow \Dyn\\
&Casts\ \begin{aligned}[t] c\ ::=&\ c : T \Rightarrow^l T\ ^{cl}\ |\ \blamecast{T}{T}{l}{cl}\ |\ \emptycast{T}{cl} \end{aligned}\\
&Cast\ Values\ \begin{aligned}[t] cv\ ::=&\ cv1\ |\ \blamecast{T}{T}{l}{cl}\\
                                cv1\ ::=&\ \emptycast{T}{cl}\ |\ cv1 : G \Rightarrow^l \Dyn\ ^{cl}\ |\ cv1 : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4\ ^{cl} \end{aligned}\\
\end{align*}

\framebox[1.2\width]{$c \cios c$}\ Evaluation
\begin{mathpar}
Push\ blame\ to\ top\ level

\inferrule* [right=E-PushBlameCI]
{ }
{\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} \cios \blamecast{T_I}{T_2}{l_1}{cl_1}}

Evaluate\ inside\ casts\\

\inferrule* [right=E-EvaluateCI]
{\neg(is\ cast\ value\ c) \\ c \cios c'}
{c : T_1 \Rightarrow^l T_2\ ^{cl} \cios c' : T_1 \Rightarrow^l T_2\ ^{cl}}\\

Detect\ success\ or\ failure\ of\ casts\\

\inferrule* [right=E-IdentityCI]
{ }
{cv1 : T \Rightarrow^l T\ ^{cl} \cios cv1}

\inferrule* [right=E-SucceedCI]
{ }
{cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \cios cv1}

\inferrule* [right=E-FailCI]
{\neg(same\ ground\ G_1\ G_2) \\ initialType(c) = T_I}
{cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \cios \blamecast{T_I}{G_2}{l_2}{cl_1}}\\

Mediate\ the\ transition\ between\ the\ two\ disciplines

\inferrule* [right=E-GroundCI]
{G\ is\ ground\ type\ of\ T \\ \neg(ground\ T)}
{cv1 : T \Rightarrow^l \Dyn\ ^{cl} \cios cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}}

\inferrule* [right=E-ExpandCI]
{G\ is\ ground\ type\ of\ T \\ \neg(ground\ T)}
{cv1 : \Dyn \Rightarrow^l T\ ^{cl} \cios cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}}
\end{mathpar}
\hrulefill
\caption{Cast Intersection Operational Semantics ($\cios$)}
\label{cast_intersection_operational_semantics}
\end{figure}

\begin{figure}[H]
Syntax
\begin{align*}
&Types\ \begin{aligned}[t] T &::=\ \Int\ |\ \Bool\ |\ \Dyn\ |\ T \rightarrow T\ |\ T \cap \ldots \cap T \end{aligned}\\
&Expressions\ \begin{aligned}[t] e\ ::=&\ x\ |\ \lambda x : T\ .\ e\ |\ e\ e\ |\ n\ |\ \true\ |\ \false\ |\ e : c \cap \ldots \cap c\ |\ \blame{T}{l} \end{aligned}\\
&Values\ \begin{aligned}[t] v\ ::=&\ x\ |\ \lambda x : T\ .\ e\ |\ n\ |\ \true\ |\ \false\ |\ \blame{T}{l}\ |\ v : cv_1 \cap \ldots \cap cv_n\ such\ that\\
                                 &\neg(\forall_{i\in 1..n}\ .\ cv_i = \blamecast{T}{T}{l}{cl})\ \land\ \neg(\forall_{i\in 1..n}\ .\ cv_i = \emptycast{T}{cl}) \end{aligned}
\end{align*}

\framebox[1.2\width]{$e \gios e$}\ Evaluation
\begin{mathpar}
Push\ blame\ to\ top\ level\\

\inferrule* [right=E-PushBlame1]
{\Gamma \iccts (\blame{T_2}{l})\ e_2 : T_1}
{(\blame{T_2}{l})\ e_2 \gios \blame{T_1}{l}}

\inferrule* [right=E-PushBlame2]
{\Gamma \iccts e_1\ (\blame{T_2}{l}) : T_1}
{e_1\ (\blame{T_2}{l}) \gios \blame{T_1}{l}}

\inferrule* [right=E-PushBlameCast]
{\cits c_1 : T_1 \ldots \cits c_n : T_n}
{\blame{T}{l} : c_1 \cap \ldots \cap c_n \gios \blame{T_1 \cap \ldots \cap T_n}{l}}\\

Evaluate\ expressions\\

\inferrule* [right=E-AppAbs]
{ }
{(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \gios\ [x \mapsto v] e}

\inferrule* [right=E-App1]
{e_1 \gios e_1'}
{e_1\ e_2 \gios\ e_1'\ e_2}

\inferrule* [right=E-App2]
{e_2 \gios e_2'}
{v_1\ e_2 \gios\ v_1\ e_2'}

\inferrule* [right=E-Evaluate]
{e \gios e'}
{e : c_1 \cap \ldots \cap c_n \gios e' : c_1 \cap \ldots \cap c_n}\\

Simulate\ casts\ on\ data\ types\\

\inferrule* [right=E-SimulateArrow]
{is\ value\ (v_1 : cv_1 \cap \ldots \cap cv_n) \\ \exists i \in 1..n\ .\ isArrowCompatible(cv_i) \\\\ ((c_{11}, c_{12}, c_1^s), \ldots, (c_{m1}, c_{m2}, c_m^s)) = simulateArrow(cv_1, \ldots, cv_n)}
{(v_1 : cv_1 \cap \ldots \cap cv_n)\ v_2 \gios\\ (v_1 : c_1^s \cap \ldots \cap c_m^s)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : c_{12} \cap \ldots \cap c_{m2}}\\

Merge\ casts\\

\inferrule* [right=E-MergeCasts]
{is\ value\ (v : cv_1 \cap \ldots \cap cv_n) \\ v : c_1'' \cap \ldots \cap c_j'' = \mergeCasts{v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m'}}
{v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m' \gios v : c_1'' \cap \ldots \cap c_j''}\\

Evaluate\ casts\\

\inferrule* [right=E-EvaluateCasts]
{\neg(\forall i \in 1..n\ .\ is\ cast\ value\ c_i) \\ c_1 \cios cv_1\ \ldots\ c_n \cios cv_n}
{v : c_1 \cap \ldots \cap c_n \gios v : cv_1 \cap \ldots \cap cv_n}\\

Transition\ from\ cast\ values\ to\ values\\

\inferrule* [right=E-PropagateBlame]
{ }
{v : \blamecast{I_1}{F_1}{l_1}{cl_1} \cap \ldots \cap \blamecast{I_n}{F_n}{l_n}{cl_n} \gios \blame{(F_1 \cap \ldots \cap F_n)}{l_1}}

\inferrule* [right=E-RemoveEmpty]
{ }
{v : \emptycast{T_1}{cl_1} \cap \ldots \cap \emptycast{T_n}{cl_n} \gios v}
\end{mathpar}
\hrulefill
\caption{Intersection Cast Calculus Operational Semantics ($\gios$)}
\label{intersection_cast_calculus_operational_semantics}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{\assignCastLabel{c}{cl} = c}
\begin{mathpar}
\inferrule* []
{}
{\assignCastLabel{c : T_1 \Rightarrow^l T_2\ ^{cl}}{cl'} = \assignCastLabel{c}{cl'} : T_1 \Rightarrow^l T_2\ ^{cl'}}\\

\inferrule* []
{}
{\assignCastLabel{\blamecast{T_I}{T_F}{l}{cl'}}{cl} = \blamecast{T_I}{T_F}{l}{cl}}\\

\inferrule* []
{}
{\assignCastLabel{\emptycast{T}{cl'}}{cl} = \emptycast{T}{cl}}\\
\end{mathpar}

\framebox[1.2\width]{isArrowCompatible(c) = Bool}
\begin{mathpar}
\inferrule* []
{}
{isArrowCompatible(c : T_{11} \rightarrow T_{12} \Rightarrow^l T_{21} \rightarrow T_{22}\ ^{cl}) = isArrowCompatible(c)}\\

\inferrule* []
{}
{isArrowCompatible(\emptycast{(T_1 \rightarrow T_2)}{cl}) = True}\\
\end{mathpar}

\framebox[1.2\width]{\separateIntersectionCast{c} = (c, c)}
\begin{mathpar}
\inferrule* []
{}
{\separateIntersectionCast{c : T_1 \Rightarrow^l T_2\ ^{cl}} = (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}, c)}\\

\inferrule* []
{}
{\separateIntersectionCast{\emptycast{T}{cl}} = (\emptycast{T}{cl}, \emptycast{T}{cl})}\\
\end{mathpar}

\framebox[1.2\width]{\breakdownArrowType{c} = (c, c)}
\begin{mathpar}
\inferrule* []
{}
{\breakdownArrowType{\emptycast{T_{11} \rightarrow T_{12}}{cl} : T_{11} \rightarrow T_{12} \Rightarrow^l T_{21} \rightarrow T_{22}\ ^{cl}} =\\ (\emptycast{T_{21}}{cl} : T_{21} \Rightarrow^l T_{11}\ ^{cl}, \emptycast{T_{12}}{cl} : T_{12} \Rightarrow^l T_{22}\ ^{cl})}\\

\inferrule* []
{}
{\breakdownArrowType{\emptycast{T_1 \rightarrow T_2}{cl}} = (\emptycast{T_1}{cl}, \emptycast{T_2}{cl}})\\
\end{mathpar}

\framebox[1.2\width]{simulateArrow($c_1, \ldots, c_n$) = $((c_{11}, c_{12}, c_1^s), \ldots, (c_{m1}, c_{m2}, c_m^s))$}
\begin{mathpar}
\inferrule* []
{(c_1', \ldots, c_m') = filter\ isArrowCompatible\ (c_1, \ldots, c_n)\\
 ((c_1^f, c_1^s), \ldots, (c_m^f, c_m^s)) = map\ separateIntersectionCast\ (\assignCastLabel{c_1'}{0}, \ldots, \assignCastLabel{c_m'}{0})\\
 ((c_{11}, c_{12}), \ldots, (c_{m1}, c_{m2})) = map\ breakdownArrowType\ (\assignCastLabel{c_1^f}{1}, \ldots, \assignCastLabel{c_m^f}{m})}
{simulateArrow(c_1, \ldots, c_n) = ((c_{11}, c_{12}, c_1^s), \ldots, (c_{m1}, c_{m2}, c_m^s))}\\
\end{mathpar}
\hrulefill
\caption{Definitions for auxiliary semantic functions}
\label{definitions}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{getCastLabel(c) = cl}
\begin{mathpar}
\inferrule* []
{}
{getCastLabel(c : T_1 \Rightarrow^l T_2\ ^{cl}) = cl}\\

\inferrule* []
{}
{getCastLabel(\blamecast{T_I}{T_F}{l}{cl}) = cl}\\

\inferrule* []
{}
{getCastLabel(\emptycast{T}{cl}) = cl}\\
\end{mathpar}

\framebox[1.2\width]{sameCastLabel(c, c) = Bool}
\begin{mathpar}
\inferrule* []
{}
{sameCastLabel(c_1, c_2) = getCastLabel(c_1) == 0}\\
\inferrule* []
{}
{sameCastLabel(c_1, c_2) = getCastLabel(c_2) == 0}\\

\inferrule* []
{}
{sameCastLabel(c_1, c_2) = getCastLabel(c_1) == getCastLabel(c_2)}\\
\end{mathpar}
\framebox[1.2\width]{joinCasts(c, c) = c}
\begin{mathpar}
\inferrule* []
{}
{joinCasts(c : T_1 \Rightarrow^l T_2\ ^{cl}, c') = joinCasts(c, c') : T_1 \Rightarrow^l T_2\ ^{cl}}\\

\inferrule* []
{}
{joinCasts(\blamecast{T_I}{T_F}{l}{cl}, c) = \blamecast{T_I}{T_F}{l}{cl}}\\

\inferrule* []
{}
{joinCasts(\emptycast{T}{cl}, c) = \assignCastLabel{c}{cl}}\\
\end{mathpar}

\framebox[1.2\width]{$\mergeCasts{e} = e$}
\begin{mathpar}
\inferrule* []
{(c_1', \ldots, c_o') = [joinCast\ y\ x\ |\ x \leftarrow (c_{11}, \ldots, c_{1m}),\ y \leftarrow (c_{21}, \ldots, c_{2n}),\\ sameCastLabel\ y\ x\ \&\&\ initialType(y) == finalType (x)]}
{\mergeCasts{e : c_{11} \cap \ldots \cap c_{1m} : c_{21} \cap \ldots \cap c_{2n}} = e : c_1' \cap \ldots \cap c_o'}\\
\end{mathpar}
\hrulefill
\caption{Definitions for auxiliary semantic functions}
\label{definitions2}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$e =_c e$}\ Equality of Casts
\begin{mathpar}
\inferrule* []
{}
{x =_c x}

\inferrule* []
{}
{n =_c n}

\inferrule* []
{}
{\true =_c \true}

\inferrule* []
{}
{\false =_c \false}

\inferrule* []
{}
{\blame{T}{l} =_c \blame{T}{l}}

\inferrule* []
{e =_c e'}
{\lambda x : T\ .\ e =_c \lambda x : T\ .\ e'}

\inferrule* []
{e_1 =_c e_1' \\ e_2 =_c e_2'}
{e_1\ e_2 =_c e_1'\ e_2'}

\inferrule* []
{e =_c e'}
{e =_c e' : (\emptycast{T}{cl})}

\inferrule* []
{}
{\blame{T}{l} =_c e : (\blamecast{T'}{T}{l}{cl})}

\inferrule* []
{e =_c e' : c}
{e : T_1 \Rightarrow^l T_2 =_c e' : (c : T_1 \Rightarrow^l T_2\ ^{cl})}
\end{mathpar}
\hrulefill
\caption{Equality of Casts}
\label{equality_casts}
\end{figure}

\newpage

\section{Gradual Intersection Lambda Calculus as an extension of the GTLC}
\begin{theorem}[Instances of Intersection Types]
\label{instances_intersection_types}
If $T \trianglelefteq \{T_1, \ldots, T_n\}$ then $\{T_1, \ldots, T_n\}$ is the set of all the instances of $T$ and for each $i \in 1 .. n$, $T_i$ is a simple type.
\end{theorem}
\begin{proof}
We proceed by structural induction on $T$.
Base cases:
\begin{itemize}
    \item $T = \Int$.
    If $\Int \trianglelefteq \{\Int\}$ then $\Int$ is the only instance of $\Int$ and $\Int$ is a simple type.
    \item $T = \Bool$.
    If $\Bool \trianglelefteq \{\Bool\}$ then $\Bool$ is the only instance of $\Bool$ and $\Bool$ is a simple type.
    \item $T = \Dyn$.
    If $\Dyn \trianglelefteq \{\Dyn\}$ then $\Dyn$ is the only instance of $\Dyn$ and $\Dyn$ is a simple type.
\end{itemize}
Induction step:
\begin{itemize}
    \item $T = T_1 \rightarrow T_2$.
    If $T_1 \rightarrow T_2 \trianglelefteq \{T_{11} \rightarrow T_2, \ldots, T_{1n} \rightarrow T_2\}$ then, by the definition of $\trianglelefteq$, $T_1 \trianglelefteq \{T_{11}, \ldots, T_{1n}\}$.
    By the induction hypothesis, $\{T_{11}, \ldots, T_{1n}\}$ is the set of all the instances of $T_1$ and $T_{11}$ and ... and $T_{1n}$ are all simple types.
    As $T_2$ is a simple type, then $T_2$ is the only instance of $T_2$.
    Therefore, $\{T_{11} \rightarrow T_2, \ldots, T_{1n} \rightarrow T_2\}$ is the set of  all the instances of $T_1 \rightarrow T_2$ and $T_{11} \rightarrow T_2$ and ... and $T_{1n} \rightarrow T_2$ are all simple types.
    \item $T = T_1 \cap \ldots \cap T_n$.
    If $T_1 \cap \ldots \cap T_n \trianglelefteq \{T_{11}, \ldots, T_{1m}, \ldots, T_{n1}, \ldots, T_{nj}\}$ then, by the definition of $\trianglelefteq$, $T_1 \trianglelefteq \{T_{11}, \ldots, T_{1m}\}$ and ... and $T_n \trianglelefteq \{T_{n1}, \ldots, T_{nj}\}$.
    By the induction hypothesis, $\{T_{11}, \ldots, T_{1m}\}$ is the set of all the instances of $T_1$ and $T_{11}$ and ... and $T_{1m}$ are all simple types and ... and $\{T_{n1}, \ldots, T_{nj}\}$ is the set of all the instances of $T_n$ and $T_{n1}$ and ... and $T_{nj}$ are all simple types.
    Then, $\{T_{11}, \ldots, T_{1m}, \ldots, T_{n1}, \ldots, T_{nj}\}$ is the set of all the instance of $T_1 \cap \ldots \cap T_n$ and $T_{11}$ and ... and $T_{1m}$ and ... and $T_{n1}$ and ... and $T_{nj}$ are all simple types.
\end{itemize}
\end{proof}

\begin{theorem}[Conservative Extension]
\label{conservative_extension_intersection_type_system}
If $e$ is annotated with only simple types and $T$ is a simple type, then $\Gamma \vdash_{G} e : T \iff \Gamma \gits e : T$.
\end{theorem}
\begin{proof}
We will first prove the right direction of the implication, that if $\Gamma \vdash_{G} e : T$ then $\Gamma \gits e : T$.
We proceed by induction on the length of the derivation tree of $\vdash_{G}$.
Base cases:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \vdash_{G} x : T$, then by rule T-Var, $x : T \in \Gamma$.
    Therefore, $\Gamma \gits x : T$.
    \item Rule T-Int.
    If $\Gamma \vdash_{G} n : \Int$, then by rule T-Int, $\Gamma \gits n : \Int$.
    \item Rule T-True.
    If $\Gamma \vdash_{G} \true : \Bool$, then by rule T-True, $\Gamma \gits \true : \Bool$.
    \item Rule T-False.
    If $\Gamma \vdash_{G} \false : \Bool$, then by rule T-False, $\Gamma \gits \false : \Bool$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    If $\Gamma \vdash_{G} \lambda x : T_1\ .\ e : T_1 \rightarrow T_2$, then by rule T-Abs, $\Gamma, x : T_1 \vdash_{G} e : T_2$.
        By the induction hypothesis, $\Gamma, x : T_1 \gits e : T_2$.
        Therefore, by rule T-Abs, $\Gamma \gits \lambda x : T_1\ .\ e : T_1 \rightarrow T_2$.
    \item Rule T-App.
    If $\Gamma \vdash_{G} e_1\ e_2 : T_2$ then by rule T-App, $\Gamma \vdash_{G} e_1 : PM$, $PM \rhd T_1 \rightarrow T_2$, $\Gamma \vdash_{G} e_2 : T'_1$ and $T'_1 \sim T_1$.
        By the induction hypothesis, $\Gamma \gits e_1 : PM$ and $\Gamma \gits e_2 : T_1'$.
        Therefore, by rule T-App, $\Gamma \gits e_1\ e_2 : T_2$.
\end{itemize}
We will now prove the left direction of the implication, that if $\Gamma \gits e : T$ then $\Gamma \vdash_{G} e : T$.
We proceed by induction on the length of the derivation tree of $\gits$.
Base cases:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \gits x : T$, then by rule T-Var, $x : T \in \Gamma$.
    Therefore, $\Gamma \vdash_{G} e : T$.
    \item Rule T-Int.
    If $\Gamma \gits n : \Int$, then by rule T-Int, $\Gamma \vdash_{G} n : \Int$.
    \item Rule T-True.
    If $\Gamma \gits \true : \Bool$, then by rule T-True, $\Gamma \vdash_{G} \true : \Bool$.
    \item Rule T-False.
    If $\Gamma \gits \false : \Bool$, then by rule T-False, $\Gamma \vdash_{G} \false : \Bool$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    If $\Gamma \gits \lambda x : T_1 : e : T_1 \rightarrow T_2$, then by rule T-Abs, $\Gamma, x : T_1 \gits e : T_2$.
    By the induction hypothesis, $\Gamma, x : T_1 \vdash_{G} e : T_2$.
    Therefore, by rule T-Abs, $\Gamma \vdash_{G} \lambda x : T_1\ .\ e : T_1 \rightarrow T_2$.
    \item Rule T-Abs'.
    If $\Gamma \gits \lambda x : T_1 : e : T_1 \rightarrow T_2$, then by rule T-Abs', $\Gamma, x : T_1 \gits e : T_2$.
    By the induction hypothesis, $\Gamma, x : T_1 \vdash_{G} e : T_2$.
    Therefore, by rule T-Abs, $\Gamma \vdash_{G} \lambda x : T_1\ .\ e : T_1 \rightarrow T_2$.
    \item Rule T-App.
    If $\Gamma \gits e_1\ e_2 : T_2$ then by rule T-App, $\Gamma \gits e_1 : PM$, $PM \rhd T_1 \rightarrow T_2$, $\Gamma \gits e_2 : T'_1$ and $T'_1 \sim T_1$.
    By the induction hypothesis, $\Gamma \vdash_{G} e_1 : PM$ and $\Gamma \vdash_{G} e_2 : T_1'$.
    Therefore, by rule T-App, $\Gamma \vdash_{G} e_1\ e_2 : T_2$.
    \item Rule T-Gen.
    If $\Gamma \gits e : T$, then by rule T-Gen, $\Gamma \gits e : T$.
    By the induction hypothesis, $\Gamma \vdash_{G} e : T$.
    \item Rule T-Inst.
    If $\Gamma \gits e : T$, then by rule T-Inst, $\Gamma \gits e : T$.
    By the induction hypothesis, $\Gamma \vdash_{G} e : T$.
\end{itemize}
\end{proof}

\begin{theorem}[Conservative Extension]
\label{conservative_extension_intersection_cast_insertion}
If $e$ is annotated with only simple types and $T$ is a simple type then $\Gamma \vdash_{CC} e \leadsto e_1 : T \iff \Gamma \iccts e \leadsto e_2 : T$ and $e_1 =_{c} e_2$.
\end{theorem}
\begin{proof}
We will first prove the right direction of the implication, that if $\Gamma \vdash_{CC} e \leadsto e_1 : T$ then $\Gamma \iccts e \leadsto e_2 : T$ and $e_1 =_{c} e_2$.
We proceed by induction on the length of the derivation tree of $\Gamma \vdash_{CC} e \leadsto e_1 : T$.
Base cases:
\begin{itemize}
    \item Rule C-Var.
    If $\Gamma \vdash_{CC} x \leadsto x : T$, then by rule C-Var, $x : T \in \Gamma$.
    Therefore, by rule C-Var, $\Gamma \iccts x \leadsto x : T$.
    \item Rule C-Int.
    If $\Gamma \vdash_{CC} n \leadsto n : \Int$, then by rule C-Int, $\Gamma \iccts n \leadsto n : \Int$.
    \item Rule C-True.
    If $\Gamma \vdash_{CC} \true \leadsto \true : \Bool$, then by rule C-True, $\Gamma \iccts \true \leadsto \true : \Bool$.
    \item Rule C-False.
    If $\Gamma \vdash_{CC} \false \leadsto \false : \Bool$, then by rule C-False, $\Gamma \iccts \false \leadsto \false : \Bool$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule C-Abs.
    If $\Gamma \vdash_{CC} \lambda x : T_1\ .\ e \leadsto \lambda x : T_1\ .\ e' : T_1 \rightarrow T_2$, then by rule C-Abs, $\Gamma, x : T_1 \vdash_{CC} e \leadsto e' : T_2$.
    By the induction hypothesis, $\Gamma, x : T_1 \iccts e \leadsto e' : T_2$.
    Therefore, by rule C-Abs, $\Gamma \iccts \lambda x : T_1\ .\ e \leadsto \lambda x : T_1\ .\ e' : T_1 \rightarrow T_2$.
    \item Rule C-App.
    If $\Gamma \vdash_{CC} e_1\ e_2 \leadsto (e_1' : PM \Rightarrow^l T_1 \rightarrow T_2)\ (e_2' : T_1' \Rightarrow^l T_1) : T_2$, then by rule C-App, $\Gamma \vdash_{CC} e_1 \leadsto e_1' : PM$, $PM \rhd T_1 \rightarrow T_2$, $\Gamma \vdash_{CC} e_2 \leadsto e_2' : T_1'$ and $T_1' \sim T_1$.
    By the induction hypothesis, $\Gamma \iccts e_1 \leadsto e_1' : PM$ and $\Gamma \iccts e_2 \leadsto e_2' : T_1'$.
    By definition of $\trianglelefteq$, $PM \trianglelefteq \{PM\}$, $T_1 \rightarrow T_2 \trianglelefteq \{T_1 \rightarrow T_2\}$, $T_1' \trianglelefteq \{T_1'\}$ and $T_1 \trianglelefteq \{T_1\}$.
    By the definition of $\hookrightarrow$, $\{PM\},\ \{T_1 \rightarrow T_2\},\ e_1' \hookrightarrow e_1' : \emptycast{PM}{0} : PM \Rightarrow^l T_1 \rightarrow T_2\ ^0$ and $\{T_1'\},\ \{T_1\},\ e_2' \hookrightarrow e_2' : \emptycast{T_1'}{0} : T_1' \Rightarrow^l T_1\ ^0$.
    Therefore, $\Gamma \iccts e_1\ e_2 \leadsto (e_1' : \emptycast{PM}{0} : PM \Rightarrow^l T_1 \rightarrow T_2\ ^0)\ (e_2' : \emptycast{T_1'}{0} : T_1' \Rightarrow^l T_1\ ^0) : T_2$.
    By the definition of $=_c$, $(e_1' : PM \Rightarrow^l T_1 \rightarrow T_2) =_c (e_1' : \emptycast{PM}{0} : PM \Rightarrow^l T_1 \rightarrow T_2\ ^0)$ and $(e_2' : T_1' \Rightarrow^l T_1) =_c (e_2' : \emptycast{T_1'}{0} : T_1' \Rightarrow^l T_1\ ^0)$.
    Therefore, $(e_1' : PM \Rightarrow^l T_1 \rightarrow T_2)\ (e_2' : T_1' \Rightarrow^l T_1) =_c (e_1' : \emptycast{PM}{0} : PM \Rightarrow^l T_1 \rightarrow T_2\ ^0)\ (e_2' : \emptycast{T_1'}{0} : T_1' \Rightarrow^l T_1\ ^0)$.
\end{itemize}
We will now prove the left direction of the implication, that if $\Gamma \iccts e \leadsto e_2 : T$ then $\Gamma \vdash_{CC} e \leadsto e_1 : T$ and $e_1 =_{c} e_2$.
We proceed by induction on the length of the derivation tree of $\Gamma \iccts e \leadsto e_2 : T$.
Base cases:
\begin{itemize}
    \item Rule C-Var.
    If $\Gamma \iccts x \leadsto x : T$, then by rule C-Var, $x : T \in \Gamma$.
    Therefore, by rule C-Var, $\Gamma \vdash_{CC} x \leadsto x : T$.
    \item Rule C-Int.
    If $\Gamma \iccts n \leadsto n : \Int$, then by rule C-Int, $\Gamma \vdash_{CC} n \leadsto n : \Int$.
    \item Rule C-True.
    If $\Gamma \iccts \true \leadsto \true : \Bool$, then by rule C-True, $\Gamma \vdash_{CC} \true \leadsto \true : \Bool$.
    \item Rule C-False.
    If $\Gamma \iccts \false \leadsto \false : \Bool$, then by rule C-False, $\Gamma \vdash_{CC} \false \leadsto \false : \Bool$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule C-Abs.
    If $\Gamma \iccts \lambda x : T_1\ .\ e \leadsto \lambda x : T_1\ .\ e' : T_1 \rightarrow T_2$, then by rule C-Abs, $\Gamma, x : T_1 \iccts e \leadsto e' : T_2$.
    By the induction hypothesis, $\Gamma, x : T_1 \vdash_{CC} e \leadsto e' : T_2$.
    Therefore, by rule C-Abs, $\Gamma \vdash_{CC} \lambda x : T_1\ .\ e \leadsto \lambda x : T_1\ .\ e' : T_1 \rightarrow T_2$.
    \item Rule C-Abs'
    If $\Gamma \iccts \lambda x : T_1\ .\ e \leadsto \lambda x : T_1\ .\ e' : T_1 \rightarrow T_2$, then by rule C-Abs', $\Gamma, x : T_1 \iccts e \leadsto e' : T_2$.
    By the induction hypothesis, $\Gamma, x : T_1 \vdash_{CC} e \leadsto e' : T_2$.
    Therefore, by rule C-Abs, $\Gamma \vdash_{CC} \lambda x : T_1\ .\ e \leadsto \lambda x : T_1\ .\ e' : T_1 \rightarrow T_2$.
    \item Rule C-App.
    If $\Gamma \iccts e_1\ e_2 \leadsto e_1''\ e_2'' : T_2$ then by rule C-App, $\Gamma \iccts e_1 \leadsto e_1' : PM$, $PM \rhd T_1 \rightarrow T_2$, $\Gamma \iccts e_2 \leadsto e_2' : T'_1$, $T'_1 \sim T_1$, $PM \trianglelefteq S_1$, $T_1 \rightarrow T_2 \trianglelefteq S_2$, $T'_1 \trianglelefteq S_3$, $T_1 \trianglelefteq S_4$, $S_1,\ S_2,\ e_1' \hookrightarrow e_1''$ and $S_3,\ S_4,\ e_2' \hookrightarrow e_2''$.
    Since $e_1\ e_2$ is annotated with only simple types, then by the definition of $\trianglelefteq$, $e_1'' = (e_1' : \emptycast{PM}{0} : PM \Rightarrow^l T_1 \rightarrow T_2\ ^0)$ and $e_2'' = (e_2' : \emptycast{T_1'}{0} : T_1' \Rightarrow^l T_1\ ^0)$.
    By the induction hypothesis, $\Gamma \vdash_{CC} e_1 \leadsto e_1' : PM$ and $\Gamma \vdash_{CC} e_2 \leadsto e_2' : T'_1$.
    Therefore, by rule C-App, $\Gamma \vdash_{CC} e_1\ e_2 \leadsto (e_1' : PM \Rightarrow^l T_1 \rightarrow T_2)\ (e_2' : T_1' \Rightarrow^l T_1) : T_2$.
    By the definition of $=_c$, $(e_1' : PM \Rightarrow^l T_1 \rightarrow T_2) =_c (e_1' : \emptycast{PM}{0} : PM \Rightarrow^l T_1 \rightarrow T_2\ ^0)$ and $(e_2' : T_1' \Rightarrow^l T_1) =_c (e_2' : \emptycast{T_1'}{0} : T_1' \Rightarrow^l T_1\ ^0)$.
    Therefore, $(e_1' : PM \Rightarrow^l T_1 \rightarrow T_2)\ (e_2' : T_1' \Rightarrow^l T_1) =_c (e_1' : \emptycast{PM}{0} : PM \Rightarrow^l T_1 \rightarrow T_2\ ^0)\ (e_2' : \emptycast{T_1'}{0} : T_1' \Rightarrow^l T_1\ ^0)$.
    \item Rule C-Gen.
    If $\Gamma \iccts e \leadsto e' : T$ then by rule C-Gen, $\Gamma \iccts e \leadsto e' : T$.
    By the induction hypothesis, $\Gamma \vdash_{CC} e \leadsto e' : T$.
    \item Rule C-Inst.
    If $\Gamma \iccts e \leadsto e' : T$ then by rule C-Inst, $\Gamma \iccts e \leadsto e' : T$.
    By the induction hypothesis, $\Gamma \vdash_{CC} e \leadsto e' : T$.
\end{itemize}
\end{proof}

\begin{theorem}[Conservative Extension]
\label{conservative_extension_intersection_cast_insertion}
Depends on Lemma \ref{progress}.
If $e_2$ are annotated with only simple types, $T$ is a simple type, $\Gamma \vdash_{CC} e_1 : T$, $\Gamma \iccts e_2 : T$ and $e_1 =_{c} e_2$ then $e_1 \longrightarrow_{CC} e_1' \iff e_2 \gios e_2'$, and $e_1' =_{c} e_2'$.
\end{theorem}
\begin{proof}
We will first prove the right direction of the implication, that if $e_1 \longrightarrow_{CC} e_1'$ then $e_2 \gios^* e_2'$ and $e_1 =_{c} e_2$.
We proceed by induction on the length of the derivation tree of $e_1 =_c e_2$.
Base cases:
\begin{itemize}
    \item $x =_c x$.
    As $x$ doesn't reduce by $\longrightarrow_{CC}$, this case is not considered.
    \item $n =_c n$.
    As $n$ doesn't reduce by $\longrightarrow_{CC}$, this case is not considered.
    \item $\true =_c \true$.
    As $\true$ doesn't reduce by $\longrightarrow_{CC}$, this case is not considered.
    \item $\false =_c \false$.
    As $\false$ doesn't reduce by $\longrightarrow_{CC}$, this case is not considered.
    \item $\blame{T}{l} =_c \blame{T}{l}$.
    As $\blame{T}{l}$ doesn't reduce by $\longrightarrow_{CC}$, this case is not considered.
    \item $\blame{T}{l} =_c e : (\blamecast{T'}{T}{l}{cl})$.
    As $\blame{T}{l}$ doesn't reduce by $\longrightarrow_{CC}$, this case is not considered.
\end{itemize}
Induction step:
\begin{itemize}
    \item $\lambda x : T\ .\ e =_c \lambda x : T\ .\ e'$.
    As $\lambda x : T\ .\ e$ doesn't reduce by $\longrightarrow_{CC}$, this case is not considered.
    \item $e_1\ e_2 =_c e_3\ e_4$.
    There are six possibilities:
    \begin{itemize}
        \item Rule E-PushBlame1.
        If $\blame{T' \rightarrow T}{l}\ e_2 = e_3\ e_4$ and $\blame{T' \rightarrow T}{l}\ e_2 \longrightarrow_{CC} \blame{T}{l}$ then by the definition of $=_c$, $\blame{T' \rightarrow T}{l} =_c e_3$.
        There are two possibilities.
        By the definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, either
        \begin{itemize}
            \item $e_3 \gios^* \blame{T' \rightarrow T}{l}$.
            By rule E-App1, $e_3\ e_4 \gios^* \blame{T' \rightarrow T}{l}\ e_4$.
            By rule E-PushBlame1, $\blame{T' \rightarrow T}{l}\ e_4 \gios^* \blame{T}{l}$ and $\blame{T}{l} =_c \blame{T}{l}$.
            \item $e_3 \gios^* e : (\blamecast{T''}{(T' \rightarrow T)}{l}{cl})$.
            By repeated application of rule E-Evaluate and by Lemma \ref{progress}, $e : \blamecast{T''}{(T' \rightarrow T)}{l}{cl}) \gios^* v : \blamecast{T''}{(T' \rightarrow T)}{l}{cl})$.
            By rule E-PropagateBlame, $v : \blamecast{T''}{(T' \rightarrow T)}{l}{cl}) \gios^* \blame{T' \rightarrow T}{l}$.
            By rule E-App1, $e_3\ e_4 \gios^* \blame{T' \rightarrow T}{l}\ e_4$.
            By rule E-PushBlame1, $\blame{T' \rightarrow T}{l}\ e_4 \gios^* \blame{T}{l}$ and $\blame{T}{l} =_c \blame{T}{l}$.
        \end{itemize}
        \item Rule E-PushBlame2.
        If $e_1\ \blame{T'}{l} = e_3\ e_4$ and $e_1\ \blame{T'}{l} \longrightarrow_{CC} \blame{T}{l}$ then by the definition of $=_c$, $\blame{T'}{l} =_c e_4$.
        There are two possibilities.
        By the definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, either
        \begin{itemize}
            \item $e_4 \gios^* \blame{T'}{l}$.
            By rule E-App2, $e_3\ e_4 \gios^* e_3\ \blame{T'}{l}$.
            By rule E-PushBlame2, $e_3\ \blame{T'}{l} \gios^* \blame{T}{l}$ and $\blame{T}{l} =_c \blame{T}{l}$.
            \item $e_4 \gios^* e : \blamecast{T''}{T'}{l}{cl}$.
            By repeated application of rule E-Evaluate and by Lemma \ref{progress}, $e : \blamecast{T''}{T'}{l}{cl} \gios^* v : \blamecast{T''}{T'}{l}{cl}$.
            By rule E-PropagateBlame, $v : \blamecast{T''}{T'}{l}{cl} \gios^* \blame{T'}{l}$.
            By rule E-App2, $e_3\ e_4 \gios^* e_3\ \blame{T'}{l}$.
            By rule E-PushBlame2, $e_3\ \blame{T'}{l} \gios^* \blame{T}{l}$ and $\blame{T}{l} =_c \blame{T}{l}$.
        \end{itemize}
        \item Rule E-App1.
        If $e_1\ e_2 =_c e_3\ e_4$ and $e_1\ e_2 \longrightarrow_{CC} e_1'\ e_2$ then by the definition of $=_c$, $e_1 =_c e_3$ and $e_2 =_c e_4$, and by rule E-App1, $e_1 \longrightarrow_{CC} e_1'$.
        By the induction hypothesis, $e_3 \gios e_3'$ and $e_1' =_c e_3'$.
        Then, by rule E-App1, $e_3\ e_4 \gios e_3'\ e_4$.
        By definition of $=_c$, $e_1'\ e_2 =_c e_3'\ e_4$.
        \item Rule E-App2.
        If $v_1\ e_2 =_c e_3\ e_4$ and $v_1\ e_2 \longrightarrow_{CC} v_1\ e_2'$ then by the definition of $=_c$, $v_1 =_c e_3$ and $e_2 =_c e_4$, and by rule E-App2, $e_2 \longrightarrow_{CC} e_2'$.
        By the induction hypothesis, $e_4 \gios e_4'$ and $e_2' =_c e_4'$.
        By definition of $=_c$, and by applying rule E-RemoveEmpty zero or more times, $e_3 \gios^* v_1$.
        If $e_3 \gios^* v_1'$ such that $v_1 =_c v_1'$, by rule E-App1, $e_3\ e_4 \gios v_1'\ e_4$, and by rule E-App2, $v_1'\ e_4 \gios v_1'\ e_4'$.
        By definition of $=_c$, $v_1\ e_2' =_c v_1'\ e_4'$.
        \item Rule E-AppAbs.
        If $(\lambda x : T'\ .\ e)\ v =_c e_3\ e_4$ and $(\lambda x : T'\ .\ e)\ v \longrightarrow_{CC} [x \mapsto v]e$ then by the definition of $=_c$, $(\lambda x : T'\ .\ e) =_c e_3$ and $v =_c e_4$.
        By the definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, $e_3 \gios^* \lambda x : T'\ .\ e'$ and $e_4 \gios^* v'$, such that, by definition of $=_c$, $(\lambda x : T'\ .\ e) = _c (\lambda x : T'\ .\ e')$ and $v =_c v'$ and $e =_c e'$.
        By rule E-AppAbs, $(\lambda x : T'\ .\ e')\ v' \gios [x \mapsto v']e'$ and by definition of $=_c$, $[x \mapsto v]e =_c [x \mapsto v']e'$.
        \item Rule C-BETA.
        If $(v_1 : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4)\ v_2 =_c e_3\ e_4$ and $(v_1 : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4)\ v_2 \longrightarrow_{CC} (v_1\ (v_2 : T_3 \Rightarrow^l T_1)) : T_2 \Rightarrow^l T_4$ then by the definition of $=_c$, $v_1 : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4 =_c e_3$ and $v_2 =_c e_4$.
        By definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, $e_3 \gios^* v_1' : (\emptycast{T_1 \rightarrow T_2}{cl} : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4)$ such that $v_1 =_c v_1'$, and $e_4 \gios^* v_2'$ such that $v_2 =_c v_2'$.
        By rule E-SimulateArrow, $(v_1' : (\emptycast{T_1 \rightarrow T_2}{cl} : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4))\ v_2' \gios ((v_1' : \emptycast{T_1 \rightarrow T_2}{cl})\ (v_2' : (\emptycast{T_3}{0} : T_3 \Rightarrow^l T_1\ ^0))) : (\emptycast{T_2}{0} : T_2 \Rightarrow^l T_4\ ^0)$.
        By the definition of $=_c$, $(v_1\ (v_2 : T_3 \Rightarrow^l T_1)) : T_2 \Rightarrow^l T_4 =_c ((v_1' : \emptycast{T_1 \rightarrow T_2}{cl})\ (v_2' : (\emptycast{T_3}{0} : T_3 \Rightarrow^l T_1\ ^0))) : (\emptycast{T_2}{0} : T_2 \Rightarrow^l T_4\ ^0)$.
    \end{itemize}
    \item $e_1 =_c e_2 : (\emptycast{T}{cl})$.
    If $e_1 =_c e_2 : \emptycast{T}{cl}$ and $e_1 \longrightarrow_{CC} e_1'$ then by the definition of $=_c$, $e_1 =_c e_2$.
    By the induction hypothesis, $e_2 \gios e_2'$ and $e_1' =_c e_2'$.
    By rule E-Evaluate, $e_2 : \emptycast{T}{cl} \gios e_2' : \emptycast{T}{cl}$.
    As $e_1' =_c e_2'$ then by definition of $=_c$, $e_1' =_c e_2' : \emptycast{T}{cl}$.
    \item $e : T_1 \Rightarrow^l T_2 =_c e' : (c : T_1 \Rightarrow^l T_2\ ^{cl})$.
    There are seven possibilities:
    \begin{itemize}
        \item Rule E-Evaluate.
        If $e_1 : T_1 \Rightarrow^l T_2 =_c e$ and $e_1 : T_1 \Rightarrow^l T_2 \longrightarrow_{CC} e_1' : T_1 \Rightarrow^l T_2$, then by the definition of $=_c$ and by applying rule E-Evaluate zero or more times, $e \gios^* e_2 : (c : T_1 \Rightarrow^l T_2\ ^{cl})$ such that $e_1 =_c e_2 : c$, and by rule E-Evaluate, $e_1 \longrightarrow_{CC} e_1'$.
        By the induction hypothesis, $e_2 : c \gios^* e_2' : c$ and $e_1' =_c e_2' : c$.
        If $e_2 : c \gios^* e_2' : c$ then by rule E-Evaluate, $e_2 \gios^* e_2'$.
        By rule E-Evaluate, $e_2 : (c : T_1 \Rightarrow^l T_2\ ^{cl}) \gios e_2' : (c : T_1 \Rightarrow^l T_2\ ^{cl})$.
        As $e_1' =_c e_2' : c$ then by the definition of $=_c$, $e_1' : T_1 \Rightarrow^l T_2 =_c e_2' : (c : T_1 \Rightarrow^l T_2\ ^{cl})$.
        \item Rule CTX-BLAME.
        If $\blame{T_1}{l} : T_1 \Rightarrow^l T_2 =_c e$ and $\blame{T_1}{l} : T_1 \Rightarrow^l T_2 \longrightarrow_{CC} \blame{T_2}{l}$ then there are three possibilities.
        By the definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, either
        \begin{itemize}
            \item $e \gios^* \blame{T_1}{l} : (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl})$.
            By rule E-PushBlameCast, $\blame{T_1}{l} : (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}) \gios \blame{T_2}{l}$ and $\blame{T_2}{l} =_c \blame{T_2}{l}$.
            \item $e \gios^* e' : (\blamecast{T'}{T_1}{l}{cl} : T_1 \Rightarrow^l T_2\ ^{cl})$.
            By repeated application of rule E-Evaluate and by Lemma \ref{progress}, $e' : (\blamecast{T'}{T_1}{l}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}) \gios^* v : (\blamecast{T'}{T_1}{l}{cl} : T_1 \Rightarrow^l T_2\ ^{cl})$.
            By rule E-EvaluateCasts and by rule E-PushBlameCI, $v : (\blamecast{T'}{T_1}{l}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}) \gios^* v : (\blamecast{T'}{T_2}{l}{cl})$.
            By rule E-PropagateBlame, $v : (\blamecast{T'}{T_2}{l}{cl}) \gios^* \blame{T_2}{l})$ and $\blame{T_2}{l} =_c \blame{T_2}{l}$.
            \item $e \gios^* e' : (\blamecast{T'}{T_1}{l}{cl}) : (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl})$.
            By repeated application of rule E-Evaluate and by Lemma \ref{progress}, $e' : (\blamecast{T'}{T_1}{l}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}) \gios^* v : (\blamecast{T'}{T_1}{l}{cl}) : (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl})$.
            By rule E-MergeCasts, $v : (\blamecast{T'}{T_1}{l}{cl}) : (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}) \gios v : (\blamecast{T'}{T_1}{l}{cl} : T_1 \Rightarrow^l T_2\ ^{cl})$.
            By rule E-EvaluateCasts and by rule E-PushBlameCI, $v : (\blamecast{T'}{T_1}{l}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}) \gios^* v : (\blamecast{T'}{T_2}{l}{cl})$.
            By rule E-PropagateBlame, $v : (\blamecast{T'}{T_2}{l}{cl}) \gios^* \blame{T_2}{l})$ and $\blame{T_2}{l} =_c \blame{T_2}{l}$.
        \end{itemize}
        \item Rule ID-BASE and Rule ID-STAR.
        If $v : T \Rightarrow^l T =_c e$ and $v : T \Rightarrow^l T \longrightarrow_{CC} v$, then by the definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, $e \gios^* v' : (cv : T \Rightarrow^l T\ ^{cl})$, such that $v =_c v' : cv$.
        By rule E-EvaluateCasts and by rule E-IdentityCI, $v' : (cv : T \Rightarrow^l T\ ^{cl}) \gios v' : cv$ and $v =_c v' : cv$.
        \item Rule SUCCEED.
        If $v : G \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G =_c e$ and $v : G \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G \longrightarrow_{CC} v$ then there are two possibilities.
        By definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, either
        \begin{itemize}
            \item $e \gios^* v' : (cv : G \Rightarrow^{l_1} \Dyn\ ^{cl} : \Dyn \Rightarrow^{l_2} G\ ^{cl})$ or
            \item $e \gios^* v' : (cv : G \Rightarrow^{l_1} \Dyn\ ^{cl}) : (\emptycast{\Dyn}{cl} : \Dyn \Rightarrow^{l_2} G\ ^{cl})$
        \end{itemize}
        such that $v =_c v' : cv$.
        As, by rule E-MergeCasts, $v' : (cv : G \Rightarrow^{l_1} \Dyn\ ^{cl}) : (\emptycast{\Dyn}{cl} : \Dyn \Rightarrow^{l_2} G\ ^{cl}) \gios v' : (cv : G \Rightarrow^{l_1} \Dyn\ ^{cl} : \Dyn \Rightarrow^{l_2} G\ ^{cl})$, we only need to address the first case.
        By rule E-EvaluateCasts and by rule E-SucceedCI, $v' : (cv : G \Rightarrow^{l_1} \Dyn\ ^{cl} : \Dyn \Rightarrow^{l_2} G\ ^{cl}) \gios v' : cv$ and $v =_c v' : cv$.
        \item Rule FAIL.
        If $v : G_1 \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G_2 =_c e$ and $v : G_1 \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G_2 \longrightarrow_{CC} \blame{G_2}{l_2}$ then there are two possibilities.
        By definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, either
        \begin{itemize}
            \item $e \gios^* v' : (cv : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl})$ or
            \item $e \gios^* v' : (cv : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl}) : (\emptycast{\Dyn}{cl} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl})$
        \end{itemize}
        such that $v =_c v' : cv$.
        As, by rule E-MergeCasts, $v' : (cv : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl}) : (\emptycast{\Dyn}{cl} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl}) \gios v' : (cv : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl})$, we only need to address the first case.
        By rule E-EvaluateCasts and by rule E-FailCI, $v' : (cv : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl}) \gios v' : \blamecast{T_I}{G_2}{l_2}{cl}$.
        By rule E-PropagateBlame, $v' : \blamecast{T_I}{G_2}{l_2}{cl} \gios \blame{G_2}{l_2}$ and $\blame{G_2}{l_2} =_c \blame{G_2}{l_2}$.
        \item Rule GROUND.
        If $v : T \Rightarrow^l \Dyn =_c e$ and $v : T \Rightarrow^l \Dyn \longrightarrow_{CC} v : T \Rightarrow^l G : G \Rightarrow^l \Dyn$ then by definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, $e \gios^* v' : (cv : T \Rightarrow^l \Dyn\ ^{cl})$ such that $v =_c v' : cv$.
        By rule E-EvaluateCasts and by rule E-GroundCI, $v' : (cv : T \Rightarrow^l \Dyn\ ^{cl}) \gios v' : (cv : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl})$.
        As $v =_c v' : cv$, then by definition of $=_c$, $v : T \Rightarrow^l G : G \Rightarrow^l \Dyn =_c v' : (cv : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl})$.
        \item Rule EXPAND.
        If $v : \Dyn \Rightarrow^l T =_c e$ and $v : \Dyn \Rightarrow^l T \longrightarrow_{CC} v : \Dyn \Rightarrow^l G : G \Rightarrow^l T$ then by definition of $=_c$ and by applying rule E-RemoveEmpty zero or more times, $e \gios^* v' : (cv : \Dyn \Rightarrow^l T\ ^{cl})$ such that $v =_c v' : cv$.
        By rule E-EvaluateCasts and by rule E-ExpandCI, $v' : (cv : \Dyn \Rightarrow^l T\ ^{cl}) \gios v' : (cv : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl})$.
        As $v =_c v' : cv$, then by definition of $=_c$, $v : \Dyn \Rightarrow^l G : G \Rightarrow^l T =_c v' : (cv : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl})$.
    \end{itemize}
\end{itemize}
We will now prove the left direction of the implication, that if $e_2 \gios e_2'$ then $e_1 \longrightarrow_{CC} e_1'$ and $e_1 =_{c} e_2$.
We proceed by induction on the length of the derivation tree of $e_1 =_c e_2$.
Base cases:
\begin{itemize}
    \item $x =_c x$.
    As $x$ doesn't reduce by $\gios$, this case is not considered.
    \item $n =_c n$.
    As $n$ doesn't reduce by $\gios$, this case is not considered.
    \item $\true =_c \true$.
    As $\true$ doesn't reduce by $\gios$, this case is not considered.
    \item $\false =_c \false$.
    As $\false$ doesn't reduce by $\gios$, this case is not considered.
    \item $\blame{T}{l} =_c \blame{T}{l}$.
    As $\blame{T}{l}$ doesn't reduce by $\gios$, this case is not considered.
    \item $\blame{T}{l} =_c e : (\blamecast{T'}{T}{l}{cl})$.
    There are two possibilities:
    \begin{itemize}
        \item Rule E-Evaluate.
        If $e : (\blamecast{T'}{T}{l}{cl}) \gios e' : (\blamecast{T'}{T}{l}{cl})$ and as $\blame{T}{l}$ is already a value, then $\blame{T}{l} =_c 'e : (\blamecast{T'}{T}{l}{cl})$.
        \item Rule E-PropagateBlame.
        If $v : (\blamecast{T'}{T}{l}{cl}) \gios \blame{T}{l}$ and as $\blame{T}{l}$ is already a value, then $\blame{T}{l} =_c \blame{T}{l}$.
    \end{itemize}
\end{itemize}
Induction step:
\begin{itemize}
    \item $\lambda x : T\ .\ e =_c \lambda x : T\ .\ e'$.
    As $\lambda x : T\ .\ e'$ doesn't reduce by $\gios$, this case is not considered.
    \item $e_1\ e_2 =_c e_3\ e_4$.
    There are 6 possibilities:
    \begin{itemize}
        \item Rule E-PushBlame1.
        If $\blame{T' \rightarrow T}{l}\ e_2 = \blame{T' \rightarrow T}{l}\ e_4$ and $\blame{T' \rightarrow T}{l}\ e_4 \gios \blame{T}{l}$ then by rule E-PushBlame1, $\blame{T' \rightarrow T}{l}\ e_2 \longrightarrow_{CC} \blame{T}{l}$ and $\blame{T}{l} =_c \blame{T}{l}$.
        \item Rule E-PushBlame2.
        If $e_1\ \blame{T'}{l} = e_3\ \blame{T'}{l}$ and $e_3\ \blame{T'}{l} \gios \blame{T}{l}$ then by rule E-PushBlame2, $e_1\ \blame{T'}{l} \longrightarrow_{CC} \blame{T}{l}$ and $\blame{T}{l} =_c \blame{T}{l}$.
        \item Rule E-App1.
        If $e_1\ e_2 =_c e_3\ e_4$ and $e_3\ e_4 \gios e_3'\ e_4$ then by the definition of $=_c$, $e_1 =_c e_3$ and $e_2 =_c e_4$, and by rule E-App1, $e_3 \gios e_3'$.
        By the induction hypothesis, $e_1 \longrightarrow_{CC} e_1'$ and $e_1' =_c e_3'$.
        Then, by rule E-App1, $e_1\ e_2 \longrightarrow_{CC} e_1'\ e_2$.
        By definition of $=_c$, $e_1'\ e_2 =_c e_3'\ e_4$.
        \item Rule E-App2.
        If $v_1\ e_2 =_c v_3\ e_4$ and $v_3\ e_4 \gios v_3\ e_4'$ then by the definition of $=_c$, $v_1 =_c v_3$ and $e_2 =_c e_4$, and by rule E-App2, $e_4 \gios e_4'$.
        By the induction hypothesis, $e_2 \longrightarrow_{CC} e_2'$ and $e_2' =_c e_4'$.
        Then, by rule E-App2, $v_1\ e_2 \longrightarrow_{CC} v_1\ e_2'$.
        By definition of $=_c$, $v_1\ e_2' =_c v_3\ e_4'$.
        \item Rule E-AppAbs.
        If $(\lambda x : T'\ .\ e)\ v_2 =_c (\lambda x : T'\ .\ e')\ v_4$ and $(\lambda x : T'\ .\ e')\ v_4 \gios [x \mapsto v_4]e'$ then by the definition of $=_c$, $(\lambda x : T'\ .\ e) =_c (\lambda x : T'\ .\ e')$ and $v_2 =_c v_4$ and $e =_c e'$.
        By rule E-AppAbs, $(\lambda x : T'\ .\ e)\ v_2 \longrightarrow_{CC} [x \mapsto v_2]e$.
        As $v_2 =_c v_4$ and $e =_c e'$, then by definition of $=_c$, $[x \mapsto v_2]e =_c [x \mapsto v_4]e'$.
        \item Rule E-SimulateArrow.
        There are two possibilities:
        \begin{itemize}
            \item If $v_1\ v_2 =_c (v_3 : \emptycast{T' \rightarrow T}{cl})\ v_4$ and $(v_3 : \emptycast{T' \rightarrow T}{cl})\ v_4 \gios ((v_3 : \emptycast{T' \rightarrow T}{cl})\ (v_4 : \emptycast{T'}{cl})) : \emptycast{T}{cl}$ then by definition of $=_c$, $v_1 =_c (v_3 : \emptycast{T' \rightarrow T}{cl})$ and $v_2 =_c v_4$ and $v_1 =_c v_3$.
            By the definition of $=_c$, $v_2 =_c v_4 : \emptycast{T'}{cl}$.
            By the definition of $=_c$, $v_1\ v_2 =_c ((v_3 : \emptycast{T' \rightarrow T}{cl})\ (v_4 : \emptycast{T'}{cl}))$.
            By the definition of $=_c$, $v_1\ v_2 =_c ((v_3 : \emptycast{T' \rightarrow T}{cl})\ (v_4 : \emptycast{T'}{cl})) : \emptycast{T}{cl}$.
            \item If $(v_1 : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4)\ v_2 =_c (v_3 : (cv : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4\ ^{cl}))\ v_4$ and $(v_3 : (cv : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4\ ^{cl}))\ v_4 \gios ((v_3 : cv)\ (v_4 : (\emptycast{T_3}{cl} : T_3 \Rightarrow^l T_1\ ^{cl}))) : (\emptycast{T}{cl} : T_2 \Rightarrow^l T_4\ ^{cl})$ then by definition of $=_c$, $v_1 =_c v_3 : cv$ and $v_2 =_c v_4$.
            By rule C-BETA, $(v_1 : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4)\ v_2 \longrightarrow_{CC} (v_1\ (v_2 : T_3 \Rightarrow^l T_1)) : T_2 \Rightarrow^l T_4$.
            As $v_2 =_c v_4$, then by definition of $=_c$, $v_2 : T_3 \Rightarrow^l T_1 =_c v_4 : (\emptycast{T_3}{cl} : T_3 \Rightarrow^l T_1\ ^{cl})$.
            As $v_1 =_c v_3 : cv$ and $v_2 : T_3 \Rightarrow^l T_1 =_c v_4 : (\emptycast{T_3}{cl} : T_3 \Rightarrow^l T_1\ ^{cl})$, then by the definition of $=_c$, $(v_1\ (v_2 : T_3 \Rightarrow^l T_1)) =_c ((v_3 : cv)\ (v_4 : (\emptycast{T_3}{cl} : T_3 \Rightarrow^l T_1\ ^{cl})))$.
            As $(v_1\ (v_2 : T_3 \Rightarrow^l T_1)) =_c ((v_3 : cv)\ (v_4 : (\emptycast{T_3}{cl} : T_3 \Rightarrow^l T_1\ ^{cl})))$, then by the definition of $=_c$, $(v_1\ (v_2 : T_3 \Rightarrow^l T_1)) : T_2 \Rightarrow^l T_4 =_c ((v_3 : cv)\ (v_4 : (\emptycast{T_3}{cl} : T_3 \Rightarrow^l T_1\ ^{cl}))) : (\emptycast{T}{cl} : T_2 \Rightarrow^l T_4\ ^{cl})$.
        \end{itemize}
    \end{itemize}
    \item $e_1 =_c e_2 : (\emptycast{T}{cl})$.
    There are two possibilities:
    \begin{itemize}
        \item Rule E-Evaluate.
        If $e_1 =_c e_2 : (\emptycast{T}{cl})$ and $e_2 : (\emptycast{T}{cl}) \gios e_2' : (\emptycast{T}{cl})$ then by the definition of $=_c$, $e_1 =_c e_2$, and by rule E-Evaluate, $e_2 \gios e_2'$.
        By the induction hypothesis, $e_1 \longrightarrow_{CC} e_1'$ and $e_1' =_c e_2'$.
        As $e_1' =_c e_2'$ then by definition of $=_c$, $e_1' =_c e_2' : (\emptycast{T}{cl})$.
        \item Rule E-RemoveEmpty.
        If $v_1 =_c v_2 : (\emptycast{T}{cl})$ and $v_2 : (\emptycast{T}{cl}) \gios v_2$ then by the definition of $=_c$, $v_1 =_c v_2$.
    \end{itemize}
    \item $e : T_1 \Rightarrow^l T_2 =_c e' : (c : T_1 \Rightarrow^l T_2\ ^{cl})$.
    There are four possibilities:
    \begin{itemize}
        \item Rule E-PushBlameCast.
        If $\blame{T_1}{l} : T_1 \Rightarrow^l T_2 =_c \blame{T_1}{l} : (c : T_1 \Rightarrow^l T_2\ ^{cl})$ and $\blame{T_1}{l} : (c : T_1 \Rightarrow^l T_2\ ^{cl}) \gios \blame{T_2}{l}$ then by rule CTX-BLAME, $\blame{T_1}{l} : T_1 \Rightarrow^l T_2 \longrightarrow_{CC} \blame{T_2}{l}$ and $\blame{T_2}{l} =_c \blame{T_2}{l}$.
        \item Rule E-Evaluate.
        If $e_1 : T_1 \Rightarrow^l T_2 =_c e_2 : (c : T_1 \Rightarrow^l T_2\ ^{cl})$ and $e_2 : (c : T_1 \Rightarrow^l T_2\ ^{cl}) \gios e_2' : (c : T_1 \Rightarrow^l T_2\ ^{cl})$ then by definition of $=_c$, $e_1 =_c e_2 : c$, and by rule E-Evaluate, $e_2 \gios e_2'$.
        By rule E-Evaluate, $e_2 : c \gios e_2' : c$.
        By the induction hypothesis, $e_1 \longrightarrow_{CC} e_1'$ and $e_1' =_c e_2' : c$.
        By rule E-Evaluate, $e_1 : T_1 \Rightarrow^l T_2 \longrightarrow_{CC} e_1' : T_1 \Rightarrow^l T_2$.
        As $e_1' =_c e_2' : c$, then by the definition of $=_c$, $e_1' : T_1 \Rightarrow^l T_2 =_c e_2' : (c : T_1 \Rightarrow^l T_2\ ^{cl})$.
        \item Rule E-MergeCasts.
        If $v : T_1 \Rightarrow^l T_2 =_c (v' : cv ) : (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl})$ and $(v' : cv ) : (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}) \gios v' : (cv : T_1 \Rightarrow^l T_2\ ^{cl})$ then by the definition of $=_c$, $v =_c v' : cv$.
        As $v =_c v' : cv$, then by the definition of $=_c$, $v : T_1 \Rightarrow^l T_2 =_c v' : (cv : T_1 \Rightarrow^l T_2\ ^{cl})$.
        \item Rule E-EvaluateCasts.
        There are seven possibilities:
        \begin{itemize}
            \item Rule E-PushBlameCI.
            If $\blame{T_1}{l_1} : T_1 \Rightarrow^{l_2} T_2 =_c v : (\blamecast{T'}{T_1}{l_1}{cl} : T_1 \Rightarrow^{l_2} T_2\ ^{cl})$ and $v : (\blamecast{T'}{T_1}{l_1}{cl} : T_1 \Rightarrow^{l_2} T_2\ ^{cl}) \gios v : \blamecast{T'}{T_2}{l_1}{cl}$ then by rule CTX-BLAME $\blame{T_1}{l_1} : T_1 \Rightarrow^{l_2} T_2 \longrightarrow_{CC} \blame{T_2}{l_1}$ and $\blame{T_2}{l_1} =_c v : \blamecast{T'}{T_2}{l_1}{cl}$.
            \item Rule E-EvaluateCI.
            If $v_1 : T_1 \Rightarrow^l T_2 =_c v_2 : (c : T_1 \Rightarrow^l T_2)$ and $v_2 : (c : T_1 \Rightarrow^l T_2) \gios v_2 : (c' : T_1 \Rightarrow^l T_2)$ then $v_1 =_c v_2 : c$ and by rule E-EvaluateCasts, $v_2 : c \gios v_2 : c'$.
            By the induction hypothesis, $v_1 \longrightarrow_{CC} v_1'$ and $v_1' =_c v_2 : c'$.
            By rule E-Evaluate, $v_1 : T_1 \Rightarrow^l T_2 \longrightarrow_{CC} v_1' : T_1 \Rightarrow^l T_2$.
            As $v_1' =_c v_2 : c'$, then by definition of $=_c$, $v_1' : T_1 \Rightarrow^l T_2 =_c v_2 : (c' : T_1 \Rightarrow^l T_2)$.
            \item E-IdentityCI.
            If $v_1 : T \Rightarrow^l T =_c v_2 : (cv1 : T \Rightarrow^l T)$ and $v_2 : (cv1 : T \Rightarrow^l T) \gios v_2 : cv1$ then by the definition of $=_c$, $v_1 =_c v_2 : cv1$.
            By rule ID-BASE or ID-STAR, $v_1 : T \rightarrow^l T \longrightarrow_{CC} v_1$ and $v_1 =_c v_2 : cv1$.
            \item E-SucceedCI.
            If $v_1 : G \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G =_c v_2 : (cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2})$ and $v_2 : (cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2}) \gios v_2 : cv1$ then by the definition of $=_c$, $v_1 =_c v_2 : cv1$.
            By rule SUCCEED, $v_1 : G \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G \longrightarrow_{CC} v_1$ and $v_1 =_c v_2 : cv1$.
            \item E-FailCI.
            If $v_1 : G_1 \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G_2 =_c v_2 : (cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2})$ and $v_2 : (cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2}) \gios v_2 : \blamecast{T'}{G_2}{l_2}{cl_1}$ then by the definition of $=_c$, $v_1 =_c v_2 : cv1$.
            By rule FAIL, $v_1 : G_1 \Rightarrow^{l_1} \Dyn : \Dyn \Rightarrow^{l_2} G_2 \longrightarrow_{CC} \blame{G_2}{l_2}$ and by the definition of $=_c$, $\blame{G_2}{l_2} =_c v_2 : \blamecast{T'}{G_2}{l_2}{cl_1}$.
            \item E-GroundCI.
            If $v_1 : T \Rightarrow^l \Dyn =_c v_2 : (cv1 : T \Rightarrow^l \Dyn\ ^{cl})$ and $v_2 : (cv1 : T \Rightarrow^l \Dyn\ ^{cl}) \gios v_2 : (cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl})$ then by the definition of $=_c$, $v_1 =_c v_2 : cv1$.
            By rule GROUND, $v_1 : T \Rightarrow^l \Dyn \longrightarrow_{CC} v_1 : T \Rightarrow^l G : G \Rightarrow^l \Dyn$.
            As $v_1 =_c v_2 : cv1$, then by the definition of $=_c$, $v_1 : T \Rightarrow^l G =_c v_2 : (cv1 : T \Rightarrow^l G\ ^{cl})$.
            As $v_1 : T \Rightarrow^l G =_c v_2 : (cv1 : T \Rightarrow^l G\ ^{cl})$, then by the definition of $=_c$, $v_1 : T \Rightarrow^l G : G \Rightarrow^l \Dyn =_c v_2 : (cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl})$.
            \item E-ExpandCI.
            If $v_1 : \Dyn \Rightarrow^l T =_c v_2 : (cv1 : \Dyn \Rightarrow^l T\ ^{cl})$ and $v_2 : (cv1 : \Dyn \Rightarrow^l T\ ^{cl}) \gios v_2 : (cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl})$ then by the definition of $=_c$, $v_1 =_c v_2 : cv1$.
            By rule EXPAND, $v_1 : \Dyn \Rightarrow^l T \longrightarrow_{CC} v_1 : \Dyn \Rightarrow^l G : G \Rightarrow^l T$.
            As $v_1 =_c v_2 : cv1$, then by the definition of $=_c$, $v_1 : \Dyn \Rightarrow^l G =_c v_2 : (cv1 : \Dyn \Rightarrow^l G\ ^{cl})$.
            As $v_1 : \Dyn \Rightarrow^l G =_c v_2 : (cv1 : \Dyn \Rightarrow^l G\ ^{cl})$, then by the definition of $=_c$, $v_1 : \Dyn \Rightarrow^l G : G \Rightarrow^l T =_c v_2 : (cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl})$.
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{proof}

\section{Correctness Criteria}
\begin{lemma}[Consistency reduces to equality when comparing static types]
\label{consistencytoequality}
If $T_1$ and $T_2$ are static types then $T_1 = T_2 \iff T_1 \sim T_2$.
\end{lemma}
\begin{proof}
We proceed by structural induction on $T_1$.\\\\
Base cases:
\begin{itemize}
    \item $T_1 = \Int$.
    \begin{itemize}
        \item If $\Int = \Int$ then, by the definition of $\sim$, $\Int \sim \Int$.
        \item If $\Int \sim \Int$, then $\Int = \Int$.
    \end{itemize}
    \item $T_1 = \Bool$.
    \begin{itemize}
        \item If $\Bool = \Bool$ then, by the definition of $\sim$, $\Bool \sim \Bool$.
        \item If $\Bool \sim \Bool$, then $\Bool = \Bool$.
    \end{itemize}
\end{itemize}
Induction step:
\begin{itemize}
    \item $T_1 = T_{11} \rightarrow T_{12}$.
    \begin{itemize}
        \item If $T_{11} \rightarrow T_{12} = T_{21} \rightarrow T_{22}$, for some $T_{21}$ and $T_{22}$, then $T_{11} = T_{21}$ and $T_{12} = T_{22}$.
        By the induction hypothesis, $T_{11} \sim T_{21}$ and $T_{12} \sim T_{22}$.
        Therefore, by the definition of $\sim$, $T_{11} \rightarrow T_{12} \sim T_{21} \rightarrow T_{22}$.
        \item If $T_{11} \rightarrow T_{12} \sim T_2$, then by the definition of $\sim$, $T_2 = T_{21} \rightarrow T_{22}$ and $T_{11} \sim T_{21}$ and $T_{12} \sim T_{22}$.
        By the induction hypothesis, $T_{11} = T_{21}$ and $T_{12} = T_{22}$.
        Therefore, $T_{11} \rightarrow T_{12} = T_{21} \rightarrow T_{22}$.
    \end{itemize}
    \item $T_1 = T_{11} \cap \ldots \cap T_{1n}$.
    \begin{itemize}
        \item If $T_{11} \cap \ldots \cap T_{1n} = T_2$, then $\exists T_{21} \ldots T_{2n}\ .\ T_2 = T_{21} \cap \ldots \cap T_{2n}$ and $T_{11} = T_{21}$ and ... and $T_{1n} = T_{2n}$.
        By the induction hypothesis, $T_{11} \sim T_{21}$ and ... and $T_{1n} \sim T_{2n}$.
        Therefore, by the definition of $\sim$, $T_{11} \cap \ldots \cap T_{1n} \sim T_{21} \cap \ldots \cap T_{2n}$.
        \item If $T_{11} \cap \ldots \cap T_{1n} \sim T_2$, then either:
        \begin{itemize}
            \item $\exists T_{21} \ldots T_{2n}\ .\ T_2 = T_{21} \cap \ldots \cap T_{2n}$ and $T_{11} \sim T_{21}$ and ... and $T_{1n} \sim T_{2n}$.
            By the induction hypothesis, $T_{11} = T_{21}$ and ... and $T_{1n} = T_{2n}$.
            Therefore, $T_{11} \cap \ldots \cap T_{1n} = T_{21} \cap \ldots \cap T_{2n}$.
            \item $T_{11} \sim T_2$ and ... and $T_{1n} \sim T_2$.
            By the induction hypothesis, $T_{11} = T_2$ and ... and $T_{1n} = T_2$.
            As $T_2 \cap \ldots \cap T_2 = T_2$, then $T_{11} \cap \ldots \cap T_{1n} = T_2$.
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{proof}

\begin{theorem}[Conservative Extension]
\label{conservative_extension_typesystem}
Depends on Lemma \ref{consistencytoequality}.
If e is fully static and T is a static type, then $\Gamma \sits e : T \iff \Gamma \gits e : T$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\sits$ and $\gits$ for the right and left direction of the implication, respectively.\\\\
Base cases:
\begin{itemize}
    \item Rule T-Var.
    \begin{itemize}
        \item If $\Gamma \sits x : T$, then $x : T \in \Gamma$.
        Therefore, $\Gamma \gits x : T$.
        \item If $\Gamma \gits x : T$, then $x : T \in \Gamma$.
        Therefore, $\Gamma \sits e : T$.
    \end{itemize}
    \item Rule T-Int.
    \begin{itemize}
        \item If $\Gamma \sits n : \Int$, then $\Gamma \gits n : \Int$.
        \item If $\Gamma \gits n : \Int$, then $\Gamma \sits n : \Int$.
    \end{itemize}
    \item Rule T-True.
    \begin{itemize}
        \item If $\Gamma \sits \true : \Bool$, then $\Gamma \gits \true : \Bool$.
        \item If $\Gamma \gits \true : \Bool$, then $\Gamma \sits \true : \Bool$.
    \end{itemize}
    \item Rule T-False.
    \begin{itemize}
        \item If $\Gamma \sits \false : \Bool$, then $\Gamma \gits \false : \Bool$.
        \item If $\Gamma \gits \false : \Bool$, then $\Gamma \sits \false : \Bool$.
    \end{itemize}
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    \begin{itemize}
        \item If $\Gamma \sits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$, then $\Gamma, x : T_1 \cap \ldots \cap T_n \sits e : T$.
        By the induction hypothesis, $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$.
        Therefore, $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$.
        \item If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$, then $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$.
        By the induction hypothesis, $\Gamma, x : T_1 \cap \ldots \cap T_n \sits e : T$.
        Therefore, $\Gamma \sits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$.
    \end{itemize}
    \item Rule T-Abs'.
    \begin{itemize}
        \item If $\Gamma \sits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$, then $\Gamma, x : T_i \sits e : T$.
        By the induction hypothesis, $\Gamma, x : T_i \gits e : T$.
        Therefore, $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$.
        \item If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$, then $\Gamma, x : T_i \gits e : T$.
        By the induction hypothesis, $\Gamma, x : T_i \sits e : T$.
        Therefore, $\Gamma \sits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$.
    \end{itemize}
    \item Rule T-App.
    \begin{itemize}
        \item If $\Gamma \sits e_1\ e_2 : T$ then $\Gamma \sits e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \sits e_2 : T_1 \cap \ldots \cap T_n$.
        By the induction hypothesis, $\Gamma \gits e_1\ : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \gits e_2 : T_1 \cap \ldots \cap T_n$.
        By the definition of $\rhd$, $T_1 \cap \ldots \cap T_n \rightarrow T \rhd T_1 \cap \ldots \cap T_n \rightarrow T$.
        By the definition of $\sim$, $T_1 \cap \ldots \cap T_n \sim T_1 \cap \ldots \cap T_n$.
        Therefore, $\Gamma \gits e_1\ e_2 : T$.
        \item If $\Gamma \gits e_1\ e_2 : T$ then $\Gamma \gits e_1 : PM$, $PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T$, $\Gamma \gits e_2 : T'_1 \cap \ldots \cap T'_n$ and $T'_1 \cap \ldots \cap T'_n \sim T_1 \cap \ldots \cap T_n$.
        By the definition of $\rhd$, $PM = T_1 \cap \ldots \cap T_n \rightarrow T$, therefore $\Gamma \gits e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$.
        By Lemma \ref{consistencytoequality}, $T'_1 \cap \ldots \cap T'_n = T_1 \cap \ldots \cap T_n$, and therefore $\Gamma \gits e_2 : T_1 \cap \ldots \cap T_n$.
        By the induction hypothesis, $\Gamma \sits e_1\ : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \sits e_2 : T_1 \cap \ldots \cap T_n$.
        Therefore, $\Gamma \sits e_1\ e_2 : T$.
    \end{itemize}
    \item Rule T-Gen.
    \begin{itemize}
        \item If $\Gamma \sits e : T_1 \cap \ldots \cap T_n$ then $\Gamma \sits e : T_1$ and ... and $\Gamma \sits e : T_n$.
        By the induction hypothesis, $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
        Therefore, $\Gamma \gits e : T_1 \cap \ldots \cap T_n$.
        \item If $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ then $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
        By the induction hypothesis, $\Gamma \sits e : T_1$ and ... and $\Gamma \sits e : T_n$.
        Therefore $\Gamma \sits e : T_1 \cap \ldots \cap T_n$.
    \end{itemize}
    \item Rule T-Inst.
    \begin{itemize}
        \item If $\Gamma \sits e : T_i$ then $\Gamma \sits e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, ..., T_n\}$.
        By the induction hypothesis, $\Gamma \gits e : T_1 \cap \ldots \cap T_n$.
        As $T_i \in \{T_1, ..., T_n\}$, then $\Gamma \gits e : T_i$.
        \item If $\Gamma \gits e : T_i$ then $\Gamma \gits e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, ..., T_n\}$.
        By the induction hypothesis, $\Gamma \sits e : T_1 \cap \ldots \cap T_n$.
        As $T_i \in \{T_1, ..., T_n\}$, then $\Gamma \sits e : T_i$.
    \end{itemize}
\end{itemize}
\end{proof}

\begin{theorem}[Monotonicity w.r.t. precision]
\label{monotonicity_wrt_precision}
If $\Gamma \gits e : T$ and $e' \sqsubseteq e$ then $\Gamma \gits e' : T'$ and $T' \sqsubseteq T$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\Gamma \gits e : T$.\\\\
Base cases:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \gits x : T$ and $x \sqsubseteq x$, then $\Gamma \gits x : T$ and $T \sqsubseteq T$.
    \item Rule T-Int.
    If $\Gamma \gits n : \Int$ and $n \sqsubseteq n$, then $\Gamma \gits n : \Int$ and $\Int \sqsubseteq \Int$.
    \item Rule T-True.
    If $\Gamma \gits \true : \Bool$ and $\true \sqsubseteq \true$, then $\Gamma \gits \true : \Bool$ and $\Bool \sqsubseteq \Bool$.
    \item Rule T-False.
    If $\Gamma \gits \false : \Bool$ and $\false \sqsubseteq \false$, then $\Gamma \gits \false : \Bool$ and $\Bool \sqsubseteq \Bool$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' \sqsubseteq \lambda x : T_1 \cap \ldots \cap T_n\ .\ e$, then by rule T-Abs, $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$, and by the definition of $\sqsubseteq$, $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$ and $e' \sqsubseteq e$.
    By the induction hypothesis, $\Gamma, x : T_1' \cap \ldots \cap T_n' \gits e' : T'$ and $T' \sqsubseteq T$.
    By rule T-Abs, $\Gamma \gits \lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' : T_1' \cap \ldots \cap T_n' \rightarrow T'$, and by the definition of $\sqsubseteq$, $T_1' \cap \ldots \cap T_n' \rightarrow T' \sqsubseteq T_1 \cap \ldots \cap T_n \rightarrow T$.
    \item Rule T-Abs'.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$ and $\lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' \sqsubseteq \lambda x : T_1 \cap \ldots \cap T_n\ .\ e$, then by rule T-Abs', $\Gamma, x : T_i \gits e : T$, and by the definition of $\sqsubseteq$, $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$ and $e' \sqsubseteq e$.
    By the induction hypothesis, $\Gamma, x : T_i' \gits e' : T'$ and $T' \sqsubseteq T$.
    By rule T-Abs', $\Gamma \gits \lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' : T_i' \rightarrow T'$, and by the definition of $\sqsubseteq$, $T_i' \rightarrow T' \sqsubseteq T_i \rightarrow T$.
    \item Rule T-App.
    If $\Gamma \gits e_1\ e_2 : T$ and $e_1'\ e_2' \sqsubseteq e_1\ e_2$ then by rule T-App, $\Gamma \gits e_1 : PM$, $PM \rhd T_{11} \cap \ldots \cap T_{1n} \rightarrow T$, $\Gamma \gits e_2 : T_{21} \cap \ldots \cap T_{2n}$, and $T_{21} \cap \ldots \cap T_{2n} \sim T_{11} \cap \ldots \cap T_{1n}$, and by the definition of $\sqsubseteq$, $e_1' \sqsubseteq e_1$ and $e_2' \sqsubseteq e_2$.
    By the induction hypothesis, $\Gamma \gits e_1' : PM'\ and\ PM' \sqsubseteq PM\ and\ PM' \rhd T_{11}' \cap \ldots \cap T_{1n}' \rightarrow T'$ and $\Gamma \gits e_2' : T_{21}' \cap \ldots \cap T_{2n}'\ and\ T_{21}' \cap \ldots \cap T_{2n}' \sqsubseteq T_{21} \cap \ldots \cap T_{2n}\ and\ T_{21}' \cap \ldots \cap T_{2n}' \sim T_{11}' \cap \ldots \cap T_{1n}'$.
    By the definition of $\sqsubseteq$ and $\rhd$, $T_{11}' \cap \ldots \cap T_{1n}' \rightarrow T' \sqsubseteq T_{11} \cap \ldots \cap T_{1n} \rightarrow T$, and therefore, $T' \sqsubseteq T$.
    As $\Gamma \gits e_1'\ e_2' : T'$, it is proved.
    \item Rule T-Gen.
    If $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ and $e' \sqsubseteq e$, then by rule T-Gen, $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
    By the induction hypothesis, $\Gamma \gits e' : T_1'\ and\ T_1' \sqsubseteq T_1$ and ... and $\Gamma \gits e' : T_n'\ and\ T_n' \sqsubseteq T_n$.
    Then by rule T-Gen, $\Gamma \gits e' : T_1' \cap \ldots \cap T_n'$ and by the definition of $\sqsubseteq$, $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$.
    \item Rule T-Inst.
    If $\Gamma \gits e : T_i$ and $e' \sqsubseteq e$, then by rule T-Inst, $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ such that $T_i \in \{T_1, ..., T_n\}$.
    By the induction hypothesis, $\Gamma \gits e' : T_1' \cap \ldots \cap T_n'$ and $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$.
    Therefore, by rule T-Inst, $\Gamma \gits e' : T_i'$ and by the definition of $\sqsubseteq$, $T_i' \sqsubseteq T_i$.
\end{itemize}
\end{proof}

\begin{theorem}[Type preservation of cast insertion]
\label{type_preservation_cast_insertion}
If $\Gamma \gits e : T$ then $\Gamma \iccts e \leadsto e' : T$ and $\Gamma \iccts e' : T$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\Gamma \gits e : T$.\\\\
Base cases:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \gits x : T$, then by rule T-Var, $x : T \in \Gamma$.
    By rule C-Var, $\Gamma \iccts x \leadsto x : T$ and by rule T-Var, $\Gamma \iccts x : T$.
    \item Rule T-Int.
    As $\Gamma \gits n : \Int$, then by rule C-Int, $\Gamma \iccts n \leadsto n : \Int$ and by rule T-Int, $\Gamma \iccts n : \Int$.
    \item Rule T-True.
    As $\Gamma \gits \true : \Bool$, then by rule C-True, $\Gamma \iccts \true \leadsto \true : \Bool$ and by rule T-True, $\Gamma \iccts \true : \Bool$.
    \item Rule T-False.
    As $\Gamma \gits \false : \Bool$, then by rule C-False, $\Gamma \iccts \false \leadsto \false : \Bool$ and by rule T-False, $\Gamma \iccts \false : \Bool$, it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ then by rule T-Abs, $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$.
    By the induction hypothesis, $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e \leadsto e' : T$ and $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e' : T$.
    By rule C-Abs, $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e \leadsto \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_1 \cap \ldots \cap T_n \rightarrow T$ and by rule T-Abs, $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_1 \cap \ldots \cap T_n \rightarrow T$.
    \item Rule T-Abs'.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$ then by rule T-Abs', $\Gamma, x : T_i \gits e : T$.
    By the induction hypothesis, $\Gamma, x : T_i \iccts e \leadsto e' : T$ and $\Gamma, x : T_i \iccts e' : T$.
    By rule C-Abs', $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e \leadsto \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_i \rightarrow T$ and by rule T-Abs', $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_i \rightarrow T$.
    \item Rule T-App.
    If $\Gamma \gits e_1\ e_2 : T$ then by rule T-App, $\Gamma \gits e_1 : PM$, $PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T$, $\Gamma \gits e_2 : T_1' \cap \ldots \cap T_n'$ and $T_1' \cap \ldots \cap T_n' \sim T_1 \cap \ldots \cap T_n$.
    By the induction hypothesis, $\Gamma \iccts e_1 \leadsto e_1' : PM$ and $\Gamma \iccts e_1' : PM$, and $\Gamma \iccts e_2 \leadsto e_2' : T_1' \cap \ldots \cap T_n'$ and $\Gamma \iccts e_2' : T_1' \cap \ldots \cap T_n'$.
    Therefore, by rule C-App, $\Gamma \iccts e_1\ e_2 \leadsto e_1''\ e_2'' : T$.
    By the definition of $\trianglelefteq$ and $S,\ S,\ e \hookrightarrow e$, by rule T-CastIntersection, $\Gamma \iccts e_1'' : T_1 \rightarrow T \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2'' : T_1 \cap \ldots \cap T_n$.
    By rule T-App', $\Gamma \iccts e_1''\ e_2'' : T \cap \ldots \cap T$ and then by the properties of intersection types (modulo repetitions), $\Gamma \iccts e_1''\ e_2'' : T$.
    \item Rule T-Gen.
    If $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ then by rule T-Gen, $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
    By the induction hypothesis, $\Gamma \iccts e \leadsto e' : T_1$ and ... and $\Gamma \iccts e \leadsto e' : T_n$, and $\Gamma \iccts e' : T_1$ and ... and $\Gamma \iccts e' : T_n$.
    By rule C-Gen, $\Gamma \iccts e \leadsto e' : T_1 \cap \ldots \cap T_n$ and by rule T-Gen, $\Gamma \iccts e' : T_1 \cap \ldots \cap T_n$.
    \item Rule T-Inst.
    If $\Gamma \gits e : T_i$ then by rule T-Inst, $\Gamma \gits e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, \ldots, T_n\}$.
    By the induction hypothesis, $\Gamma \iccts e \leadsto e' : T_1 \cap \ldots \cap T_n$ and $\Gamma \iccts e' : T_1 \cap \ldots \cap T_n$.
    By rule C-Inst, $\Gamma \iccts e \leadsto e' : T_i$ and by rule T-Inst, $\Gamma \iccts e' : T_i$.
\end{itemize}
\end{proof}

\begin{theorem}[Monotonicity w.r.t precision of cast insertion]
\label{monotonicity_wrt_precision_cast_insertion}
If $\Gamma \iccts e_1 \leadsto e_1' : T_1$ and $\Gamma \iccts e_2 \leadsto e_2' : T_2$ and $e_1 \sqsubseteq e_2$ then $e_1' \sqsubseteq e_2'$ and $T_1 \sqsubseteq T_2$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\Gamma \iccts e_1 \leadsto e_1' : T$.
Base cases:
\begin{itemize}
    \item Rule C-Var.
    If $\Gamma \iccts x \leadsto x : T$ and $\Gamma \iccts x \leadsto x : T$, and $x \sqsubseteq x$, then $x \sqsubseteq x$ and $T \sqsubseteq T$.
    \item Rule C-Int.
    If $\Gamma \iccts n \leadsto n : \Int$, $\Gamma \iccts n \leadsto n : \Int$ and $n \sqsubseteq n$, then $n \sqsubseteq n$ and $\Int \sqsubseteq \Int$.
    \item Rule C-True.
    If $\Gamma \iccts \true \leadsto \true : \Bool$, $\Gamma \iccts \true \leadsto \true : \Bool$ and $\true \sqsubseteq \true$, then $\true \sqsubseteq \true$ and $\Bool \sqsubseteq \Bool$.
    \item Rule C-False.
    If $\Gamma \iccts \false \leadsto \false : \Bool$, $\Gamma \iccts \false \leadsto \false : \Bool$ and $\false \sqsubseteq \false$, then $\false \sqsubseteq \false$ and $\Bool \sqsubseteq \Bool$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule C-Abs.
    If $\Gamma \iccts \lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1 \leadsto \lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1' : T_{11} \cap \ldots \cap T_{1n} \rightarrow T_1$ and $\Gamma \iccts \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2 \leadsto \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2' : T_{21} \cap \ldots \cap T_{2n} \rightarrow T_2$ and $\lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1 \sqsubseteq \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2$ then by rule C-Abs, $\Gamma, x : T_{11} \cap \ldots \cap T_{1n} \iccts e_1 \leadsto e_1': T_1$ and $\Gamma, x : T_{21} \cap \ldots \cap T_{2n} \iccts e_2 \leadsto e_2': T_2$ and by the definition of $\sqsubseteq$, $T_{11} \cap \ldots \cap T_{1n} \sqsubseteq T_{21} \cap \ldots \cap T_{2n}$ and $e_1 \sqsubseteq e_2$.
    By the induction hypothesis, $e_1' \sqsubseteq e_2'$ and $T_1 \sqsubseteq T_2$.
    Therefore, by the definition of $\sqsubseteq$, $\lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1' \sqsubseteq \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2'$ and $T_{11} \cap \ldots \cap T_{1n} \rightarrow T_1 \sqsubseteq T_{21} \cap \ldots \cap T_{2n} \rightarrow T_2$.
    \item Rule C-Abs'.
    If $\Gamma \iccts \lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1 \leadsto \lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1': T_{1i} \rightarrow T_1$, such that $T_{1i} \in \{T_{11}, \ldots, T_{1n}\}$, and $\Gamma \iccts \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2 \leadsto \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2' : T_{2i} \rightarrow T_2$, such that $T_{2i} \in \{T_{21}, \ldots, T_{2n}\}$, and $\lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1 \sqsubseteq \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2$ then by the definition of C-Abs', $\Gamma, x : T_{1i} \iccts e_1 \leadsto e_1': T_1$ and $\Gamma, x : T_{2i} \iccts e_2 \leadsto e_2': T_2$ and by the definition of $\sqsubseteq$, $T_{11} \cap \ldots \cap T_{1n} \sqsubseteq T_{21} \cap \ldots \cap T_{2n}$ and $e_1 \sqsubseteq e_2$ and therefore $T_{1i} \sqsubseteq T_{2i}$.
    By the induction hypothesis, $e_1' \sqsubseteq e_2'$ and $T_1 \sqsubseteq T_2$.
    Therefore, by the definition of $\sqsubseteq$, $\lambda x : T_{11} \cap \ldots \cap T_{1n}\ .\ e_1' \sqsubseteq \lambda x : T_{21} \cap \ldots \cap T_{2n}\ .\ e_2'$ and $T_{1i} \rightarrow T_1 \sqsubseteq T_{2i} \rightarrow T_2$.
    \item Rule C-App.
    If $\Gamma \iccts e_{11}\ e_{12} \leadsto e_{11}''\ e_{12}'' : T_1$ and $\Gamma \iccts e_{21}\ e_{22} \leadsto e_{21}''\ e_{22}'' : T_2$ and $e_{11}\ e_{12} \sqsubseteq e_{21}\ e_{22}$ then by rule C-App, $\Gamma \iccts e_{11} \leadsto e_{11}' : PM_1$ and $PM_1 \rhd T_{11} \cap \ldots \cap T_{1n} \rightarrow T_1$ and $\Gamma \iccts e_{12} \leadsto e_{12}' : T_{11}' \cap \ldots \cap T_{1n}'$ and $T_{11}' \cap \ldots \cap T_{1n}' \sim T_{11} \cap \ldots \cap T_{1n}$ and $PM_1 \trianglelefteq S_{11}$ and $T_{11} \cap \ldots \cap T_{1n} \rightarrow T_1 \trianglelefteq S_{12}$ and $T_{11}' \cap \ldots \cap T_{1n}' \trianglelefteq S_{13}$ and $T_{11} \cap \ldots \cap T_{1n} \trianglelefteq S_{14}$ and $S_{11},\ S_{12},\ e_{11}' \hookrightarrow e_{11}''$ and $S_{13},\ S_{14},\ e_{12}' \hookrightarrow e_{12}''$ and $\Gamma \iccts e_{21} \leadsto e_{21}' : PM_2$ and $PM_2 \rhd T_{21} \cap \ldots \cap T_{2n} \rightarrow T_2$ and $\Gamma \iccts e_{22} \leadsto e_{22}' : T_{21}' \cap \ldots \cap T_{2n}'$ and $T_{21}' \cap \ldots \cap T_{2n}' \sim T_{21} \cap \ldots \cap T_{2n}$ and $PM_2 \trianglelefteq S_{21}$ and $T_{21} \cap \ldots \cap T_{2n} \rightarrow T_2 \trianglelefteq S_{22}$ and $T_{21}' \cap \ldots \cap T_{2n}' \trianglelefteq S_{23}$ and $T_{21} \cap \ldots \cap T_{2n} \trianglelefteq S_{24}$ and $S_{21},\ S_{22},\ e_{21}' \hookrightarrow e_{21}''$ and $S_{23},\ S_{24},\ e_{22}' \hookrightarrow e_{22}''$.
    As, by the definition of $\sqsubseteq$, $e_{11} \sqsubseteq e_{21}$ and $e_{12} \sqsubseteq e_{22}$ then by the induction hypothesis, $e_{11}' \sqsubseteq e_{21}'$ and $PM_1 \sqsubseteq PM_2$ and $e_{12}' \sqsubseteq e_{22}'$ and $T_{11}' \cap \ldots \cap T_{1n}' \sqsubseteq T_{21}' \cap \ldots \cap T_{2n}'$.
    By the definition of $\rhd$, we have that $PM_1 = T_{11} \cap \ldots \cap T_{1n} \rightarrow T_1$ and $PM_2 = T_{21} \cap \ldots \cap T_{2n} \rightarrow T_2$ and so $T_{11} \cap \ldots \cap T_{1n} \rightarrow T_1 \sqsubseteq T_{21} \cap \ldots \cap T_{2n} \rightarrow T_2$ and therefore by the definition of $\sqsubseteq$, $T_1 \sqsubseteq T_2$.
    As by the definition of $\trianglelefteq$, $S,\ S,\ e \hookrightarrow e$ and $\sqsubseteq$, $e_{11}'' \sqsubseteq e_{21}''$ and $e_{12}'' \sqsubseteq e_{22}''$, then by the definition of $\sqsubseteq$, $e_{11}''\ e_{12}'' \sqsubseteq e_{21}''\ e_{22}''$ and $T_1 \sqsubseteq T_2$.
    \item Rule C-Gen.
    If $\Gamma \iccts e_1 \leadsto e_1' : T_{11} \cap \ldots \cap T_{1n}$ and $\Gamma \iccts e_2 \leadsto e_2' : T_{21} \cap \ldots \cap T_{2n}$ and $e_1 \sqsubseteq e_2$ then by rule C-Gen, $\Gamma \iccts e_1 \leadsto e_1' : T_{11}$ and ... and $\Gamma \iccts e_1 \leadsto e_1' : T_{1n}$ and $\Gamma \iccts e_2 \leadsto e_2' : T_{21}$ and ... and $\Gamma \iccts e_2 \leadsto e_2' : T_{2n}$.
    By the induction hypothesis, $e_1' \sqsubseteq e_2'$ and $T_{11} \sqsubseteq T_{21}$ and ... and $T_{1n} \sqsubseteq T_{2n}$, and therefore by the definition of $\sqsubseteq$, $T_{11} \cap \ldots \cap T_{1n} \sqsubseteq T_{21} \cap \ldots \cap T_{2n}$.
    \item Rule C-Inst.
    If $\Gamma \iccts e_1 \leadsto e_1' : T_{1i}$ and $\Gamma \iccts e_2 \leadsto e_2' : T_{2i}$ and $e_1 \sqsubseteq e_2$ then by rule C-Inst, $\Gamma \iccts e_1 \leadsto e_1' : T_{11} \cap \ldots \cap T_{1n}$ and $\Gamma \iccts e_2 \leadsto e_2' : T_{21} \cap \ldots \cap T_{2n}$.
    By the induction hypothesis, $e_1' \sqsubseteq e_2'$ and $T_{11} \cap \ldots \cap T_{1n} \sqsubseteq T_{21} \cap \ldots \cap T_{2n}$, and therefore, by the definition of $\sqsubseteq$, $T_{1i} \sqsubseteq T_{2i}$.
\end{itemize}
\end{proof}

\begin{corollary}[Monotonicity of cast insertion]
\label{monotonicity_cast_insertion}
Corollary of Theorem \ref{monotonicity_wrt_precision_cast_insertion}.
If $\Gamma \iccts e_1 \leadsto e_1' : T_1$ and $\Gamma \iccts e_2 \leadsto e_2' : T_2$ and $e_1 \sqsubseteq e_2$ then $e_1' \sqsubseteq e_2'$.
\end{corollary}

\begin{theorem}[Conservative Extension]
\label{conservative_extension_operational_semantics}
If e is fully static, then $e \sios e' \iff e \gios e'$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\sios$ and $\gios$ for the right and left direction of the implication, respectively.
Base cases:
\begin{itemize}
    \item Rule E-AppAbs.
    If $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \sios [x \mapsto v]e$ and $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \gios [x \mapsto v]e$, then it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule E-App1.
    \begin{itemize}
        \item If $e_1\ e_2 \sios e_1'\ e_2$ then by rule E-App1, $e_1 \sios e_1'$.
        By the induction hypothesis, $e_1 \gios e_1'$.
        Therefore, by rule E-App1, $e_1\ e_2 \gios e_1'\ e_2$
        \item If $e_1\ e_2 \gios e_1'\ e_2$ then by rule E-App1, $e_1 \gios e_1'$.
        By the induction hypothesis, $e_1 \sios e_1'$.
        Therefore, by rule E-App1, $e_1\ e_2 \sios e_1'\ e_2$
    \end{itemize}
    \item Rule E-App2.
    \begin{itemize}
        \item If $v_1\ e_2 \sios v_1\ e_2'$ then by rule E-App2, $e_2 \sios e_2'$.
        By the induction hypothesis, $e_2 \gios e_2'$.
        Therefore, by rule E-App2, $v_1\ e_2 \gios v_1\ e_2'$
        \item If $v_1\ e_2 \gios v_1\ e_2'$ then by rule E-App2, $e_2 \gios e_2'$.
        By the induction hypothesis, $e_2 \sios e_2'$.
        Therefore, by rule E-App2, $v_1\ e_2 \sios v_1\ e_2'$
    \end{itemize}
\end{itemize}
\end{proof}

\begin{lemma}[Type preservation of $\cios$]
\label{type_preservationCI}
If $c \cios c$ and
\begin{itemize}
    \item $\cits c : T$ then $\cits c' : T$.
    \item $initialType(c) = T$ then $initialType(c') = T$.
\end{itemize}
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\cios$.\\\\
Base cases:
\begin{itemize}
    \item Rule E-PushBlameCI.
    \begin{itemize}
        \item If $\cits \blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} : T_2$ and by rule E-PushBlameCI, $\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} \cios \blamecast{T_I}{T_2}{l_1}{cl_1}$, then by rule T-BlameCI, $\cits \blamecast{T_I}{T_2}{l_1}{cl_1} : T_2$, then it is proved.
        \item By the definition of $initialType$, $initialType(\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2}) = T_I$.
        By rule E-PushBlameCI, $\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} \cios \blamecast{T_I}{T_2}{l_1}{cl_1}$.
        Since $initialType(\blamecast{T_I}{T_2}{l_1}{cl_1}) = T_I$, it is proved.
    \end{itemize}
    \item Rule E-IdentityCI.
    \begin{itemize}
        \item If $\cits cv1 : T \Rightarrow^l T\ ^{cl} : T$, then by rule T-SingleCI, $\cits cv1 : T$.
        By rule E-IdentityCI, $cv1 : T \Rightarrow^l T\ ^{cl} \cios cv1$.
        \item By the definitions of $initialType$, $initialType(cv1 : T \Rightarrow^l T\ ^{cl}) = initialType(cv1)$.
        By rule E-IdentityCI, $cv1 : T \Rightarrow^l T\ ^{cl} \cios cv1$.
    \end{itemize}
    \item Rule E-SucceedCI.
    \begin{itemize}
        \item If $\cits cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} : G$, then by rule T-SingleCI, $\cits cv1 : G$.
        By rule E-SucceedCI, $cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \cios cv1$.
        \item By the definition of $initialType$, $initialType(cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2}) = initialType(cv1)$.
        By rule E-SucceedCI, $cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \cios cv1$.
        Therefore it is proved.
    \end{itemize}
    \item Rule E-FailCI.
    \begin{itemize}
        \item If $\cits cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} : G_2$, and by rule E-FailCI, $cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \cios \blamecast{T_I}{G_2}{l_2}{cl_1}$ then by rule T-BlameCI, $\cits \blamecast{T_I}{G_2}{l_2}{cl_1} : G_2$.
        \item By the definition of $initialType$, $initialType(cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2}) = T_I$.
        By rule E-FailCI, $cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \cios \blamecast{T_I}{G_2}{l_2}{cl_1}$, then $initialType(\blamecast{T_I}{G_2}{l_2}{cl_1}) = T_I$.
    \end{itemize}
    \item Rule E-GroundCI.
    \begin{itemize}
        \item If $\cits cv1 : T \Rightarrow^l \Dyn\ ^{cl} : \Dyn$ then by rule T-SingleCI, $\cits cv1 : T$.
        By rule E-GroundCI, $cv1 : T \Rightarrow^l \Dyn\ ^{cl} \cios cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}$, then by rule T-SingleCI, $\cits cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl} : \Dyn$.
        \item By the definition of $initialType$, $initialType(cv1 : T \Rightarrow^l \Dyn\ ^{cl}) = initialType(cv1)$.
        By rule E-GroundCI, $cv1 : T \Rightarrow^l \Dyn\ ^{cl} \cios cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}$, then $initialType(cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}) = initialType(cv1)$.
    \end{itemize}
    \item Rule E-ExpandCI.
    \begin{itemize}
        \item If $\cits cv1 : \Dyn \Rightarrow^l T\ ^{cl} : T$ then by rule T-SingleCI, $\cits cv1 : \Dyn$.
        By rule E-ExpandCI, $cv1 : \Dyn \Rightarrow^l T\ ^{cl} \cios cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}$, then by rule T-SingleCI, $\cits cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl} : T$.
        \item By the definition of $initialType$, $initialType(cv1 : \Dyn \Rightarrow^l T\ ^{cl}) = initialType(cv1)$.
        By rule E-ExpandCI, $cv1 : \Dyn \Rightarrow^l T\ ^{cl} \cios cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}$.
        Since $initialType(cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}) = initialType(cv1)$, it is proved.
    \end{itemize}
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule E-EvaluateCI.
    \begin{itemize}
        \item If $\cits c : T_1 \Rightarrow^l T_2\ ^{cl} : T_2$ then by rule T-SingleCI, $\cits c : T_1$.
        By rule E-EvaluateCI, $c \cios c'$.
        By the induction hypothesis, $\cits c' : T_1$.
        By rule E-EvaluateCI, $c : T_1 \Rightarrow^l T_2\ ^{cl} \cios c' : T_1 \Rightarrow^l T_2\ ^{cl}$, then by rule T-SingleCI, $\cits c' : T_1 \Rightarrow^l T_2\ ^{cl} : T_2$.
        \item By the definition of $initialType$, $initialType(c : T_1 \Rightarrow^l T_2\ ^{cl}) = initialType(c)$.
        By rule E-EvaluateCI, $c \cios c'$.
        By the induction hypothesis, $initialType(c') = initialType(c)$.
        By rule E-EvaluateCI, $c : T_1 \Rightarrow^l T_2\ ^{cl} \cios c' : T_1 \Rightarrow^l T_2\ ^{cl}$.
        Since $initialType(c' : T_1 \Rightarrow^l T_2\ ^{cl}) = initialType(c')$, it is proved.
    \end{itemize}
\end{itemize}
\end{proof}

\begin{lemma}[Progress of $\cios$]
\label{progressCI}
If $\Gamma \cits c : T$ and $initialType(c) = T_I$ then either $c$ is a cast value or there exists a $c'$ such that $c \cios c'$.
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\cits c : T$.\\\\
Base cases:
\begin{itemize}
    \item Rule T-BlameCI.
    As $\cits \blamecast{T_I}{T_F}{l}{cl} : T_F$, $initialType(\blamecast{T_I}{T_F}{l}{cl}) = T_I$ and $\blamecast{T_I}{T_F}{l}{cl}$ is a cast value, it is proved.
    \item Rule T-EmptyCI.
    As $\cits \emptycast{T}{cl} : T$, $initialType(\emptycast{T}{cl}) = T$ and $\emptycast{T}{cl}$ is a cast value, it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-SingleCI.
    If $\cits c : T_1 \Rightarrow^l T_2\ ^cl : T_2$ and $initialType(c : T_1 \Rightarrow^l T_2\ ^cl) = T_I$ then by rule T-SingleCI, $\cits c : T_1$ and $initialType(c) = T_I$.
    By the induction hypothesis, either $c$ is a cast value or there is a $c'$ such that $c \cios c'$.
    If $c$ is a cast value, then $c$ can either be of the form $\blamecast{T_I}{T_F}{l}{cl}$, in which case by rule E-PushBlameCI, $\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} \cios \blamecast{T_I}{T_2}{l_1}{cl_1}$ or $c$ is a cast value 1.
    If $c$ is a cast value 1 then $c : T_1 \Rightarrow^l T_2\ ^cl$ can be of one of the folowing forms:
    \begin{itemize}
        \item $cv1 : T \Rightarrow^l T\ ^{cl}$. Then by rule E-IdentityCI, $cv1 : T \Rightarrow^l T\ ^{cl} \cios cv1$.
        \item $cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2}$. Then by rule E-SucceedCI, $cv1 : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \cios cv1$.
        \item $cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2}$. Then by rule E-FailCI, $cv1 : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \cios \blamecast{T_I}{G_2}{l_2}{cl_1}$.
        \item $cv1 : T \Rightarrow^l \Dyn\ ^{cl}$. Then by rule E-GroundCI, $cv1 : T \Rightarrow^l \Dyn\ ^{cl} \cios cv1 : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}$.
        \item $cv1 : \Dyn \Rightarrow^l T\ ^{cl}$. Then by rule E-ExpandCI, $cv1 : \Dyn \Rightarrow^l T\ ^{cl} \cios cv1 : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}$.
    \end{itemize}
    If there is a $c'$ such that $c \cios c'$, then by rule E-EvaluateCI, $c : T_1 \Rightarrow^l T_2\ ^cl \cios c' : T_1 \Rightarrow^l T_2\ ^cl$.
\end{itemize}
\end{proof}

\begin{lemma}[Type preservation of $\gios$]
\label{type_preservation}
Depends on Lemmas \ref{type_preservationCI} and \ref{progressCI}.
If $\Gamma \iccts e : T_1 \cap \ldots \cap T_n$ and $e \gios e'$ then $\Gamma \iccts e' : T_1 \cap \ldots \cap T_m$ such that $m \leq n$.
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\gios$.\\\\
Base cases:
\begin{itemize}
    \item Rule E-PushBlame1.
    If $\Gamma \iccts \blame{T_2}{l}\ e_2 : T_1$ and $\blame{T_2}{l}\ e_2 \gios \blame{T_1}{l}$ then by rule T-Blame, $\Gamma \iccts \blame{T_1}{l} : T_1$.
    \item Rule E-PushBlame2.
    If $\Gamma \iccts e_1\ \blame{T_2}{l} : T_1$ and $e_1\ \blame{T_2}{l} \gios \blame{T_1}{l}$ then by rule T-Blame, $\Gamma \iccts \blame{T_1}{l} : T_1$.
    \item Rule E-PushBlameCast.
    If $\Gamma \iccts \blame{T}{l} : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$ and $\blame{T}{l} : c_1 \cap \ldots \cap c_n \gios \blame{T_1 \cap \ldots \cap T_n}{l}$ then by rule T-Blame, $\Gamma \iccts \blame{T_1 \cap \ldots \cap T_n}{l} : T_1 \cap \ldots \cap T_n$.
    \item Rule E-AppAbs.
    There exists a type $T_1 \cap \ldots \cap T_n$ such that we can deduce $\Gamma \iccts (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v : T$ from $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts v : T_1 \cap \ldots \cap T_n$ ($x$ does not occur in $\Gamma$).
    Moreover, $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ only if $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e : T$.
    By rule E-AppAbs, $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \gios [x \mapsto v] e$.
    To obtain $\Gamma \iccts [x \mapsto v] e : T$, it is sufficient to replace, in the proof of $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e : T$, the statements $x : T_i$ (introduzed by the rules T-Var and T-Inst) by the deductions of $\Gamma \iccts v : T_i$ for $1 \leq i \leq n$.
    (Proof adapted from \cite{coppo1980extension})
    \item Rule E-SimulateArrow.
    If $\Gamma \iccts (v_1 : cv_1 \cap \ldots \cap cv_n)\ v_2 : T_{12} \cap \ldots \cap T_{n2}$, then by rule T-App', $\Gamma \iccts v_1 : cv_1 \cap \ldots \cap cv_n : T_1 \cap \ldots \cap T_n$ such that $\exists i \in 1 .. n\ .\ T_i = T_{i1} \rightarrow T_{i2}$ and $\Gamma \iccts v_2 : T_{11} \cap \ldots \cap T_{n1}$.
    As $\Gamma \iccts v_1 : cv_1 \cap \ldots \cap cv_n : T_1 \cap \ldots \cap T_n$, then by rule T-CastIntersection, $\Gamma \iccts v_1 : T_1'' \cap \ldots \cap T_l''$ and $\cits cv_1 : T_1$ and ... and $\cits cv_n : T_n$ and $I_1 = initialType(cv_1)$ and ... and $I_n = initialType(cv_n)$ such that $\{I_1, \ldots, I_n\} \subseteq \{T_1'', \ldots, T_l''\}$ and $I_1 \cap \ldots \cap I_n = T_1'' \cap \ldots \cap T_n''$ and $n \leq l$.
    For the sake of simplicity lets elide cast labels and blame labels.
    By the definition of SimulateArrow, we have that $c_1' = c_1'' : T_{11}' \rightarrow T_{12}' \Rightarrow T_{11} \rightarrow T_{12}$ and ... and $c_m' = c_m'' : T_{m1}' \rightarrow T_{m2}' \Rightarrow T_{m1} \rightarrow T_{m2}$, for some $m \leq n$.
    Also, $c_{11} = \emptycast{T_{11}}{} : T_{11} \Rightarrow T_{11}'$ and ... and $c_{m1} = \emptycast{T_{m1}}{} : T_{m1} \Rightarrow T_{m1}'$ and $c_{12} : \emptycast{T_{12}'}{} : T_{12}' \Rightarrow T_{12}$ and ... and $c_{m2} = \emptycast{T_{m2}'}{} : T_{m2}' \Rightarrow T_{m2}$ and $initialType(c^s_1) = I_1$ and ... and $initialType(c^s_m) = I_m$ and $\cits c^s_1 : T_{11}' \rightarrow T_{12}'$ and ... and $\cits c^s_m : T_{m1}' \rightarrow T_{m2}'$.
    As by rule T-Gen and T-Inst $\Gamma \iccts v_1 : T_1'' \cap \ldots \cap T_m''$ and $I_1 \cap \ldots \cap I_m = T_1'' \cap \ldots \cap T_m''$, then by rule T-CastIntersection, $\Gamma \iccts v_1 : c^s_1 \cap \ldots \cap c^s_m : T_{11}' \rightarrow T_{12}' \cap \ldots \cap T_{m1}' \rightarrow T_{m2}'$.
    As by rule T-Gen and T-Inst $\Gamma \iccts v_2 : T_{11} \cap \ldots \cap T_{m1}$ and $\cits c_{11} : T_{11}'$ and ... and $\cits c_{m1} : T_{m1}'$ and $initialType(c_{11}) = T_{11}$ and ... and $initialType(c_{m1}) = T_{m1}$, then by rule T-CastIntersection, $\Gamma \iccts v_2 : c_{11} \cap \ldots \cap c_{m1} : T_{11}' \cap \ldots \cap T_{m1}'$.
    Therefore, by rule T-App', $\Gamma \iccts (v_1 : c^s_1 \cap \ldots \cap c^s_m)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : T_{12}' \cap \ldots \cap T_{m2}'$.
    As $\cits c_{12} : T_{12}$ and ... and $\cits c_{m2} : T_{m2}$ and $initialType(c_{12}) = T_{12}'$ and ... and $initialType(c_{m2}) = T_{m2}'$, then by rule T-CastIntersection, $\Gamma \iccts (v_1 : c^s_1 \cap \ldots \cap c^s_m)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : c_{12} \cap \ldots \cap c_{m2} : T_{12} \cap \ldots \cap T_{m2}$.
    By rule E-SimulateArrow, $(v_1 : cv_1 \cap \ldots \cap cv_n)\ v_2 \gios\\ (v_1 : c^s_1 \cap \ldots \cap c^s_m)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : c_{12} \cap \ldots \cap c_{m2}$, therefore it is proved.
    \item Rule E-MergeCasts.
    If $\Gamma \iccts v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m' : F_1' \cap \ldots \cap F_m'$ then by rule T-CastIntersections, $\Gamma \iccts v : cv_1 \cap \ldots \cap cv_n : F_1 \cap \ldots \cap F_n$ and $\cits c_1' : F_1'$ and ... and $\cits c_m' : F_m'$ and $initialType(c_1') = I_1'$ and $initialType(c_m') = I_m'$ such that $\{I_1', \ldots, I_m'\} \subseteq \{F_1, \ldots, F_n\}$ and $I_1' \cap \ldots \cap I_m' = F_1 \cap \ldots \cap F_m$ and $m \leq n$.
    As $\Gamma \iccts v : cv_1 \cap \ldots \cap cv_n : F_1 \cap \ldots \cap F_n$ then by rule T-CastIntersection, $\Gamma \iccts v : T_1 \cap \ldots \cap T_l$ and $\cits cv_1 : F_1$ and ... and $\cits cv_n : F_n$ and $initialType(cv_1) : I_1$ and ... and $initialType(cv_n) : I_n$ such that $\{I_1, \ldots, I_n\} \subseteq \{T_1, \ldots, T_l\}$ and $I_1 \cap \ldots \cap I_n = T_1 \cap \ldots \cap T_n$ and $n \leq l$.
    By the definition of mergeCasts, $\cits c_1'' : F_1''$ and ... and $\cits c_j'' : F_j''$ and $initialType(c_1'') = I_1''$ and ... and $initialType(c_j'') = I_j''$ such that $\{I_1'', \ldots, I_j''\} \subseteq \{T_1, \ldots, T_l\}$ and $I_1'' \cap \ldots \cap I_j'' = T_1 \cap \ldots \cap T_j$ and $\{F_1'', \ldots, F_j''\} \subseteq \{F_1', \ldots, F_m'\}$ and $F_1'' \cap \ldots \cap F_j'' = F_1' \cap \ldots \cap F_j'$ and $j \leq l$ and $j \leq m$.
    By rule T-Gen and T-Inst, $\Gamma \iccts v : T_1 \cap \ldots \cap T_j$ and therefore by rule T-CastIntersection, $\Gamma \iccts v : c_1'' \cap \ldots \cap c_j'' : F_1'' \cap \ldots \cap F_j''$.
    By rule E-MergeCasts, $v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m' \gios v : c_1'' \cap \ldots \cap c_j''$.
    \item Rule E-EvaluateCasts.
    If $\Gamma \iccts v : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$ then by rule T-CastIntersection, $\Gamma \iccts v : T_1' \cap \ldots \cap T_n'$ and $\cits c_1 : T_1$ and ... and $\cits c_n : T_n$ and $I_1 = initialType(c_1)$ and ... and $I_n = initialType(c_n)$ and $I_1 \cap \ldots \cap I_n = T_1' \cap \ldots \cap T_n'$.
    By rule E-EvaluateCasts, $c_1 \cios cv_1$ and ... and $c_n \cios cv_n$.
    By Lemmas \ref{type_preservationCI} and \ref{progressCI}, $\cits cv_1 : T_1$ and $initialType(cv_1) = I_1$ and ... and $\cits cv_n : T_n$ and $initialType(cv_n) = I_n$.
    Therefore by rule T-CastIntersection, $\Gamma \iccts v : cv_1 \cap \ldots \cap cv_n : T_1 \cap \ldots \cap T_n$.
    By rule E-EvaluateCasts, $v : c_1 \cap \ldots \cap c_n \gios v : cv_1 \cap \ldots \cap cv_n$.
    \item Rule E-PropagateBlame.
    If $\Gamma \iccts v : \blamecast{T_1'}{T_1}{l_1}{m_1} \cap \ldots \cap \blamecast{T_n'}{T_n}{l_n}{m_n} : T_1 \cap \ldots \cap T_n$ and by rule E-PropagateBlame $v : \blamecast{T_1'}{T_1}{l_1}{m_1} \cap \ldots \cap \blamecast{T_n'}{T_n}{l_n}{m_n} \gios \blame{(T_1 \cap \ldots \cap T_n)}{l_1}$, then by rule T-Blame, $\Gamma \iccts \blame{(T_1 \cap \ldots \cap T_n)}{l_1} : T_1 \cap \ldots \cap T_n$.
    \item Rule E-RemoveEmpty.
    If $\Gamma \iccts v : \emptycast{T_1}{m_1} \cap \ldots \cap \emptycast{T_n}{m_n} : T_1 \cap \ldots \cap T_n$, then by rule T-CastIntersection, $\Gamma \iccts v : T_1 \cap \ldots \cap T_n$ and $\cits \emptycast{T_1}{m_1} : T_1$ and ... and $\cits \emptycast{T_n}{m_n} : T_n$ and $initialType(\emptycast{T_1}{m_1}) = T_1$ and ... and $initialType(\emptycast{T_n}{m_n}) = T_n$.
    Therefore, by rule E-RemoveEmpty, $v : \emptycast{T_1}{m_1} \cap \ldots \cap \emptycast{T_n}{m_n} \gios v$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule E-App1. There are two possibilities:
    \begin{itemize}
        \item If $\Gamma \iccts e_1\ e_2 : T$, then by rule T-App, $\Gamma \iccts e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2 : T_1 \cap \ldots \cap T_n$.
        By rule E-App1, $e_1 \cios e_1'$, so by the induction hypothesis, $\Gamma \iccts e_1' : T_1 \cap \ldots \cap T_n \rightarrow T$.
        As by rule E-App1, $e_1\ e_2 \cios e_1'\ e_2$, then by rule T-App, $\Gamma \iccts e_1'\ e_2 : T$.
        \item If $\Gamma \iccts e_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}$, then by rule T-App', $\Gamma \iccts e_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$ and $\Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}$.
        By rule E-App1, $e_1 \cios e_1'$, so by the induction hypothesis, $\Gamma \iccts e_1' : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$.
        As by rule E-App1, $e_1\ e_2 \cios e_1'\ e_2$, then by rule T-App', $\Gamma \iccts e_1'\ e_2 : T_{12} \cap \dots \cap T_{n2}$.
    \end{itemize}
    \item Rule E-App2. There are two possibilities:
    \begin{itemize}
        \item If $\Gamma \iccts v_1\ e_2 : T$, then by rule T-App, $\Gamma \iccts v_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2 : T_1 \cap \ldots \cap T_n$.
        By rule E-App2, $e_2 \cios e_2'$, so by the induction hypothesis, $\Gamma \iccts e_2' : T_1 \cap \ldots \cap T_n$.
        As by rule E-App2, $v_1\ e_2 \cios v_1\ e_2'$, then by rule T-App, $\Gamma \iccts v_1\ e_2' : T$.
        \item If $\Gamma \iccts v_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}$, then by rule T-App', $\Gamma \iccts v_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$ and $\Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}$.
        By rule E-App2, $e_2 \cios e_2'$, so by the induction hypothesis, $\Gamma \iccts e_2' : T_{11} \cap \ldots \cap T_{n1}$.
        As by rule E-App1, $v_1\ e_2 \cios v_1\ e_2'$, then by rule T-App', $\Gamma \iccts v_1\ e_2' : T_{12} \cap \dots \cap T_{n2}$..
    \end{itemize}
    \item Rule E-Evaluate. If $\Gamma \iccts e : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$, then by rule T-CastIntersection, $\Gamma \iccts e : T_1' \cap \ldots \cap T_n'$, $\cits c_1 : T_1$ and ... and $\cits c_n : T_n$ and $initialType(c_1) \cap \ldots \cap initialType(c_n) = T_1' \cap \ldots \cap T_n'$.
    By rule E-Evaluate, $e \cios e'$, so by the induction hypothesis, $\Gamma \iccts e' : T$.
    As by rule E-Evaluate, $e : c_1 \cap \ldots \cap c_n \cios e' : c_1 \cap \ldots \cap c_n$, then by rule T-CastIntersection, $\Gamma \iccts e' : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$.
\end{itemize}
\end{proof}

\begin{lemma}[Progress of $\gios$]
\label{progress}
If $\Gamma \iccts e : T$ then either $e$ is a value or there exists an $e'$ such that $e \gios e'$.
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\Gamma \iccts e : T$.\\\\
Base cases:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \iccts x : T$, then $x$ is a value.
    \item Rule T-Int.
    If  $\Gamma \iccts n : \Int$ then $n$ is a value.
    \item Rule T-True.
    If $\Gamma \iccts \true : \Bool$ then $\true$ is a value.
    \item Rule T-False.
    If $\Gamma \iccts \false : \Bool$ then $\false$ is a value.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    If $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ then $\lambda x : T_1 \cap \ldots \cap T_n\ .\ e$ is a value.
    \item Rule T-Abs'.
    If $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$ then $\lambda x : T_1 \cap \ldots \cap T_n\ .\ e$ is a value.
    \item Rule T-App.
    If $\Gamma \iccts e_1\ e_2 : T$ then by rule T-App, $\Gamma \iccts e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2 : T_1 \cap \ldots \cap T_n$.
    By the induction hypothesis, $e_1$ is either a value or there is a $e_1'$ such that $e_1 \gios e_1'$ and $e_2$ is either a value or there is a $e_2'$ such that $e_2 \gios e_2'$.
    If $e_1$ is a value, then by rule E-PushBlame1, $(\blame{T_2}{l})\ e_2 \gios \blame{T_1}{l}$.
    If $e_2$ is a value, then by rule E-PushBlame2, $e_1\ (\blame{T_2}{l}) \gios \blame{T_1}{l}$.
    If $e_1$ is not a value, then by rule E-App1, $e_1\ e_2 \gios e_1'\ e_2$.
    If $e_1$ is a value and $e_2$ is not a value, then by rule E-App2, $v_1\ e_2 \gios v_1\ e_2'$.
    If both $e_1$ and $e_2$ are values then $e_1$ must be an abstraction $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)$, and by rule E-AppAbs $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v_2 \gios [x \mapsto v_2]e$.
    \item Rule T-Gen.
    If $\Gamma \iccts e : T_1 \cap \ldots \cap T_n$ then by rule T-Gen, $\Gamma \iccts e : T_1$ and ... and $\Gamma \iccts e : T_n$.
    By the induction hypothesis, either $e$ is a value or there exists an $e'$ such that $e \gios e'$.
    \item Rule T-Inst.
    If $\Gamma \iccts e : T_i$ then by rule T-Inst, $\Gamma \iccts e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, \ldots, T_n\}$.
    By the induction hypothesis, either $e$ is a value or there exists an $e'$ such that $e \gios e'$.
    \item Rule T-App'.
    If $\Gamma \iccts e_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}$ then by rule T-App', $\Gamma \iccts e_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$ and $\Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}$.
    By the induction hypothesis, $e_1$ is either a value or there is a $e_1'$ such that $e_1 \gios e_1'$ and $e_2$ is either a value or there is a $e_2'$ such that $e_2 \gios e_2'$.
    If $e_1$ is a value, then by rule E-PushBlame1, $(\blame{T_2}{l})\ e_2 \gios \blame{T_1}{l}$.
    If $e_2$ is a value, then by rule E-PushBlame2, $e_1\ (\blame{T_2}{l}) \gios \blame{T_1}{l}$.
    If $e_1$ is not a value, then by rule E-App1, $e_1\ e_2 \gios e_1'\ e_2$.
    If $e_1$ is a value and $e_2$ is not a value, then by rule E-App2, $v_1\ e_2 \gios v_1\ e_2'$.
    If both $e_1$ and $e_2$ are values then $e_1$ must be an abstraction $(\lambda x : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2} .\ e)$, and by rule E-AppAbs $(\lambda x : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}\ .\ e)\ v_2 \gios [x \mapsto v_2]e$.
    \item Rule T-CastIntersection.
    If $\Gamma \iccts e : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$ then by rule T-CastIntersection, $\Gamma \iccts e : T_1' \cap \ldots \cap T_n'$.
    By the induction hypothesis, $e$ is either a value, or there is an $e'$ such that $e \gios e'$.
    If $e$ is a value, then either by rule E-EvaluateCasts, $v : c_1 \cap \ldots \cap c_n \gios v : cv_1 \cap \ldots \cap cv_n$, or by rule E-PushBlameCast, $\blame{T_1' \cap \ldots \cap T_n'}{l} : c_1 \cap \ldots \cap c_n \gios \blame{T_1 \cap \ldots \cap T_n}{l}$.
    If there is an $e'$ such that $e \gios e'$, then by rule E-Evaluate, $e : c_1 \cap \ldots \cap c_n \gios e' : c_1 \cap \ldots \cap c_n$.
    \item Rule T-Blame.
    If $\Gamma \iccts \blame{T}{l} : T$ then $\blame{T}{l}$ is a value.
\end{itemize}
\end{proof}

\begin{theorem}[Type Safety of $\gios$]
\label{type_safety}
Depends on Lemmas \ref{type_preservation} and \ref{progress}.
Both Type Preservation and Progress hold for $\gios$.
\end{theorem}
\begin{proof}
We have Type Preservation (by Lemma \ref{type_preservation}) and Progress (by Lemma \ref{progress}) for $\gios$.
\end{proof}

\begin{theorem}[Blame Theorem]
\label{blame_theorem}
If $\Gamma \iccts e : T$ and $e \gios^* \blame{T}{l}$ then l is not a safe cast of $e$.
\end{theorem}

\begin{theorem}[Gradual Guarantee]
\label{gradual_guarantee}
If $\Gamma \iccts e_1 : T_1$ and $\Gamma \iccts e_2 : T_2$ and $e_1 \sqsubseteq e_2$ then:
\begin{enumerate}
    \item if $e_2 \gios e_2'$ then $e_1 \gios^* e_1'$ and $e_1' \sqsubseteq e_2'$.
    \item if $e_1 \gios e_1'$ then either $e_2 \gios^* e_2'$ and $e_1' \sqsubseteq e_2'$ or $e_2 \gios^* \blame{T_2}{l}$.
\end{enumerate}
\end{theorem}

\bibliographystyle{unsrt}
\bibliography{bibliography}

\end{document}
