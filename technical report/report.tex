\documentclass[a4paper]{article}

\include{packages}

\newtheorem{theorem}{Theorem}
\newtheorem{lemma}{Lemma}

\begin{document}

\title{Gradual Intersection Types}

\author{Pedro Ângelo, Mário Florido}

\maketitle
\pagenumbering{arabic}

\section{Language Definition}
\begin{figure}[H]
Syntax
\begin{align*}
&Types\ \begin{aligned}[t] I &::=\ \Int\ |\ \Bool\ |\ \Dyn\ |\ I \rightarrow T\ |\ I \cap \ldots \cap I\\
                          T &::=\ \Int\ |\ \Bool\ |\ \Dyn\ |\ T \rightarrow T \end{aligned}\\
&Ground\ Types\ G\ ::=\ \Int\ |\ \Bool\ |\ \Dyn \rightarrow \Dyn\\
&Casts\ \begin{aligned}[t] c\ ::=&\ c : T \Rightarrow^l T\ ^{cl}\ |\ \blamecast{T}{T}{l}{cl}\ |\ \emptycast{T}{cl} \end{aligned}\\
&Expressions\ \begin{aligned}[t] e\ ::=&\ x\ |\ \lambda x : I\ .\ e\ |\ e\ e\ |\ n\ |\ \true\ |\ \false\\
                                      |&\ e : c \cap \ldots \cap c\ |\ \blame{I}{l} \end{aligned}\\
&Cast\ Values\ \begin{aligned}[t] cv\ ::=&\ cv1\ |\ cv2\\
                                cv1\ ::=&\ \emptycast{T}{cl} : G \Rightarrow^l \Dyn\ ^{cl}\\
                                       |&\ \emptycast{T}{cl} : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4\ ^{cl}\\
                                       |&\ cv1 : G \Rightarrow^l \Dyn\ ^{cl}\\
                                       |&\ cv1 : T_1 \rightarrow T_2 \Rightarrow^l T_3 \rightarrow T_4\ ^{cl}\\
                                cv2\ ::=&\ \blamecast{T}{T}{l}{cl}\\
                                       |&\ \emptycast{T}{cl} \end{aligned}\\
&Values\ \begin{aligned}[t] v\ ::=&\ x\ |\ \lambda x : I\ .\ e\ |\ n\ |\ \true\ |\ \false\ |\ \blame{I}{l}\\
                                 |&\ v : cv_1 \cap \ldots \cap cv_n\ such\ that\\
                                 &\neg(\forall_{i\in 1..n}\ .\ cv_i = \blamecast{T}{T}{l}{cl})\ \land\\
                                 &\neg(\forall_{i\in 1..n}\ .\ cv_i = \emptycast{T}{cl}) \end{aligned}
\end{align*}
\hrulefill
\caption{Gradual Intersection System}
\label{intersection_syntax}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$\Gamma \gits e : T$}\ Typing
\begin{mathpar}
\inferrule* [right=T-Var]
{x : T \in \Gamma}
{\Gamma \gits x : T}

\inferrule* [right=T-Abs]
{\Gamma, x : T_1 \cap \ldots \cap T_n \gits\ e : T}
{\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T}

\inferrule* [right=T-Abs']
{\Gamma, x : T_i \gits\ e : T}
{\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T}

\inferrule* [right=T-App]
{\Gamma \gits e_1 : PM \\
 PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T \\\\
 \Gamma \gits e_2 : T_1' \cap \ldots \cap T_n' \\
 T_1' \cap \ldots \cap T_n' \sim T_1 \cap \ldots \cap T_n}
{\Gamma \gits e_1\ e_2 : T}

\inferrule* [right=T-Gen]
{\Gamma \gits e : T_1\ \ldots\ \Gamma \gits e : T_n}
{\Gamma \gits e : T_1 \cap \ldots \cap T_n}

\inferrule* [right=T-Inst]
{\Gamma \gits e : T_1 \cap \ldots \cap T_n}
{\Gamma \gits e : T_i}

\inferrule* [right=T-Int]
{ }
{\Gamma \gits n : \Int}

\inferrule* [right=T-True]
{ }
{\Gamma \gits \true : \Bool}

\inferrule* [right=T-False]
{ }
{\Gamma \gits \false : \Bool}
\end{mathpar}

\framebox[1.2\width]{$T \sim T$}\ Consistency
\begin{mathpar}
\inferrule* []
{}
{B \sim B}

\inferrule* []
{}
{T \sim \Dyn}

\inferrule* []
{}
{\Dyn \sim T}

\inferrule* []
{T_1 \sim T_3 \\ T_2 \sim T_4}
{T_1 \rightarrow T_2 \sim T_3 \rightarrow T_4}

\inferrule* []
{T_1 \sim T'_1\ \ldots\ T_n \sim T'_n}
{T_1 \cap \ldots \cap T_n \sim T'_1 \cap \ldots \cap T'_n}

\inferrule* []
{T \sim T_1\ \ldots\ T \sim T_n}
{T \sim T_1 \cap \ldots \cap T_n}

\inferrule* []
{T_1 \sim T\ \ldots\ T_n \sim T}
{T_1 \cap \ldots \cap T_n \sim T}
\end{mathpar}

\framebox[1.2\width]{$T \rhd T$}\ Pattern Matching
\begin{mathpar}
\inferrule* []
{}
{T_1 \rightarrow T_2 \rhd T_1 \rightarrow T_2}

\inferrule* []
{}
{\Dyn \rhd \Dyn \rightarrow \Dyn}
\end{mathpar}

\framebox[1.2\width]{$T \sqsubseteq T$}\ Type Precision
\begin{mathpar}
\inferrule* []
{}
{\Dyn \sqsubseteq T}

\inferrule* []
{}
{B \sqsubseteq B}

\inferrule* []
{T_1 \sqsubseteq T_3 \\ T_2 \sqsubseteq T_4}
{T_1 \rightarrow T_2 \sqsubseteq T_3 \rightarrow T_4}

\inferrule* []
{T_1 \sqsubseteq T'_1\ \ldots\ T_n \sqsubseteq T'_n}
{T_1 \cap \ldots \cap T_n \sqsubseteq T'_1 \cap \ldots \cap T'_n}

\inferrule* []
{T \sqsubseteq T_1\ \ldots\ T \sqsubseteq T_n}
{T \sqsubseteq T_1 \cap \ldots \cap T_n}

\inferrule* []
{T_1 \sqsubseteq T\ \ldots\ T_n \sqsubseteq T}
{T_1 \cap \ldots \cap T_n \sqsubseteq T}
\end{mathpar}

\framebox[1.2\width]{$e \sqsubseteq e$}\ Term Precision
\begin{mathpar}
\inferrule* []
{}
{x \sqsubseteq x}

\inferrule* []
{T \sqsubseteq T' \\ e \sqsubseteq e'}
{\lambda x : T\ .\ e \sqsubseteq \lambda x : T'\ .\ e'}

\inferrule* []
{e_1 \sqsubseteq e_1' \\e_2 \sqsubseteq e_2'}
{e_1\ e_2 \sqsubseteq e_1'\ e_2'}
\end{mathpar}
\hrulefill
\caption{Gradual Intersection Type System ($\gits$)}
\label{intersection_type_system}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$\Gamma \iccts e : T$}\ Typing
\begin{mathpar}
\inferrule* []
{}
{static\ type\ system\ ($$\Gamma \sits e : T$$)\ rules\ and}\\

\inferrule* [right=T-App']
{\Gamma \iccts e_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2} \\
 \Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}}
{\Gamma \iccts e_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}}

\inferrule* [right=T-IntersectionCast]
{\Gamma \iccts e : T \\ \icts c_1 : T_1\ \ldots\ \icts c_n : T_n \\\\ initialType(c_1) \cap \ldots \cap initialType(c_n) = T}
{\Gamma \iccts e : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n}

\inferrule* [right=T-Blame]
{ }
{\Gamma \iccts \blame{T}{l} : T}
\end{mathpar}

\framebox[1.2\width]{initialType(c) = T}
\begin{mathpar}
\inferrule* []
{}
{initialType(c : T_1 \Rightarrow^l T_2\ ^{cl}) = initialType(c)}\\

\inferrule* []
{}
{initialType(\emptycast{T}{cl}) = T}\\

\inferrule* []
{}
{initialType(\blamecast{T_I}{T_F}{l}{cl}) = T_I}
\end{mathpar}

\framebox[1.2\width]{finalType(c) = T}
\begin{mathpar}
\inferrule* []
{}
{finalType(c : T_1 \Rightarrow^l T_2\ ^{cl}) = T_2}\\

\inferrule* []
{}
{finalType(\emptycast{T}{cl}) = T}\\

\inferrule* []
{}
{finalType(\blamecast{T_I}{T_F}{l}{cl}) = T_F}
\end{mathpar}
\hrulefill
\caption{Intersection Cast Calculus ($\iccts$)}
\label{intersection_cast_calculus}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$\Gamma \iccts e \leadsto e : T$}\ Compilation
\begin{mathpar}
\inferrule* [right=C-Var]
{x : T \in \Gamma}
{\Gamma \iccts x \leadsto x : T}

\inferrule* [right=C-Abs]
{\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e \leadsto e' : T}
{\Gamma \iccts (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e) \leadsto (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e') : T_1 \cap \ldots \cap T_n \rightarrow T}

\inferrule* [right=C-Abs']
{\Gamma, x : T_i \iccts e \leadsto e' : T}
{\Gamma \iccts (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e) \leadsto (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e') : T_i \rightarrow T}

\inferrule* [right=C-App]
{\Gamma \iccts e_1 \leadsto e_1' : PM \\ PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T \\ \Gamma \iccts e_2 \leadsto e_2' : T'_1 \cap \ldots \cap T'_n \\ T'_1 \cap \ldots \cap T'_n \sim T_1 \cap \ldots \cap T_n \\ instances(PM) = S_1 \\ instances(T_1 \cap \ldots \cap T_n \rightarrow T) = S_2 \\ instances(T'_1 \cap \ldots \cap T'_n) = S_3 \\ instances(T_1 \cap \ldots \cap T_n) = S_4 \\ S_1,\ S_2,\ e_1' \hookrightarrow e_1'' \\ S_3,\ S_4,\ e_2' \hookrightarrow e_2''}
{\Gamma \iccts e_1\ e_2 \leadsto e_1''\ e_2'' : T}

\inferrule* [right=C-Gen]
{\Gamma \iccts e \leadsto e' : T_1\ \ldots\ \Gamma \iccts e \leadsto e' : T_n}
{\Gamma \iccts e \leadsto e': T_1 \cap \ldots \cap T_n}

\inferrule* [right=C-Inst]
{\Gamma \iccts e \leadsto e' : T_1 \cap \ldots \cap T_n}
{\Gamma \iccts e \leadsto e' : T_i}

\inferrule* [right=C-Int]
{ }
{\Gamma \iccts n \leadsto n : \Int}

\inferrule* [right=C-True]
{ }
{\Gamma \iccts \true \leadsto \true : \Bool}

\inferrule* [right=C-False]
{ }
{\Gamma \iccts \false \leadsto \false : \Bool}
\end{mathpar}

\framebox[1.2\width]{instances(T) = \{T\}}
\begin{mathpar}
\inferrule* []
{}
{instances(\Int) = \{\Int\}}\\

\inferrule* []
{}
{instances(\Bool) = \{\Bool\}}\\

\inferrule* []
{}
{instances(\Dyn) = \{\Dyn\}}\\

\inferrule* []
{instances(T_1) = \{T_{11}, \ldots, T_{1n}\}}
{instances(T_1 \rightarrow T_2) = \{T_{11} \rightarrow T_2, \ldots, T_{1n} \rightarrow T_2\}}\\

\inferrule* []
{instances(T_1) = \{T_{11}, \ldots, T_{1m}\} \ldots instances(T_n) = \{T_{n1}, \ldots, T_{nj}\}}
{instances(T_1 \cap \ldots \cap T_n) = \{T_{11}, \ldots, T_{1m}, \ldots, T_{n1}, \ldots, T_{nj}\}}
\end{mathpar}

\framebox[1.2\width]{$S,\ S,\ e \hookrightarrow e$}
\begin{mathpar}
\inferrule* []
{}
{\{T_1\},\ \{T_2\},\ e \hookrightarrow e : (\emptycast{T_1}{0} : T_1 \Rightarrow^l T_2\ ^{0})}\\

\inferrule* []
{}
{\{T_{11}, \ldots, T_{1n}\},\ \{T_{21}, \ldots, T_{2n}\},\ e \hookrightarrow e : (\emptycast{T_{11}}{0} : T_{11} \Rightarrow^{l_1} T_{21}\ ^{0}) \cap \ldots \cap (\emptycast{T_{1n}}{0} : T_{1n} \Rightarrow^{l_n} T_{2n}\ ^{0})}\\

\inferrule* []
{}
{\{T_{11}, \ldots, T_{1n}\},\ \{T_2\},\ e \hookrightarrow e : (\emptycast{T_{11}}{0} : T_{11} \Rightarrow^{l_1} T_2\ ^{0}) \cap \ldots \cap (\emptycast{T_{1n}}{0} : T_{1n} \Rightarrow^{l_n} T_2\ ^{0})}\\

\inferrule* []
{}
{\{T_1\},\ \{T_{21}, \ldots, T_{2n}\},\ e \hookrightarrow e : (\emptycast{T_1}{0} : T_1 \Rightarrow^{l_1} T_{21}\ ^{0}) \cap \ldots \cap (\emptycast{T_1}{0} : T_1 \Rightarrow^{l_n} T_{2n}\ ^{0})}
\end{mathpar}
\hrulefill
\caption{Compilation to the Cast Calculus}
\label{intersection_cast_insertion}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$e \gios e$}\ Evaluation
\begin{mathpar}
\inferrule* [right=E-App1]
{e_1 \gios e_1'}
{e_1\ e_2 \gios\ e_1'\ e_2}

\inferrule* [right=E-App2]
{e_2 \gios e_2'}
{v_1\ e_2 \gios\ v_1\ e_2'}

\inferrule* [right=E-AppAbs]
{ }
{(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \gios\ [x \mapsto v] e}

\inferrule* [right=E-Evaluate]
{e \gios e'}
{e : c_1 \cap \ldots \cap c_n \gios e' : c_1 \cap \ldots \cap c_n}\\

Simulate\ casts\ on\ data\ types

\inferrule* [right=E-SimulateArrow]
{is\ value\ (v_1 : cv_1 \cap \ldots \cap cv_n) \\ \exists i \in 1..n\ .\ isArrowCompatible(cv_i) \\\\ ((c_{11}, c_{12}, c_1^s), \ldots, (c_{m1}, c_{m2}, c_m^s)) = simulateArrow(cv_1, \ldots, cv_n)}
{(v_1 : cv_1 \cap \ldots \cap cv_n)\ v_2 \gios\\ (v_1 : c_1^s \cap \ldots \cap c_m^s)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : c_{12} \cap \ldots \cap c_{m2}}\\

Merge\ casts\\

\inferrule* [right=E-MergeCasts]
{is\ value\ (v : cv_1 \cap \ldots \cap cv_n) \\ v : c_1'' \cap \ldots \cap c_j'' = \mergeCasts{v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m'}}
{v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m' \gios v : c_1'' \cap \ldots \cap c_j''}\\

Evaluate\ intersection\ casts

\inferrule* [right=E-EvaluateCasts]
{\neg(\forall i \in 1..n\ .\ is\ cast\ value\ c_i) \\ c_1 \icos cv_1\ \ldots\ c_n \icos cv_n}
{v : c_1 \cap \ldots \cap c_n \gios v : cv_1 \cap \ldots \cap cv_n}\\

Transition\ from\ cast\ values\ to\ values

\inferrule* [right=E-PropagateBlame]
{ }
{v : \blamecast{I_1}{F_1}{l_1}{cl_1} \cap \ldots \cap \blamecast{I_n}{F_n}{l_n}{cl_n} \gios \blame{(F_1 \cap \ldots \cap F_n)}{l_1}}

\inferrule* [right=E-RemoveEmpty]
{ }
{v : \emptycast{T_1}{cl_1} \cap \ldots \cap \emptycast{T_n}{cl_n} \gios v}
\end{mathpar}
\hrulefill
\caption{Cast Calculus Semantics ($\gios$)}
\label{casts_calculus_semantics}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{\assignCastLabel{c}{cl} = c}
\begin{mathpar}
\inferrule* []
{}
{\assignCastLabel{c : T_1 \Rightarrow^l T_2\ ^{cl}}{cl'} = \assignCastLabel{c}{cl'} : T_1 \Rightarrow^l T_2\ ^{cl'}}\\

\inferrule* []
{}
{\assignCastLabel{\blamecast{T_I}{T_F}{l}{cl'}}{cl} = \blamecast{T_I}{T_F}{l}{cl}}\\

\inferrule* []
{}
{\assignCastLabel{\emptycast{T}{cl'}}{cl} = \emptycast{T}{cl}}\\
\end{mathpar}

\framebox[1.2\width]{isArrowCompatible(c) = Bool}
\begin{mathpar}
\inferrule* []
{}
{isArrowCompatible(c : T_{11} \rightarrow T_{12} \Rightarrow^l T_{21} \rightarrow T_{22}\ ^{cl}) = isArrowCompatible(c)}\\

\inferrule* []
{}
{isArrowCompatible(\emptycast{(T_1 \rightarrow T_2)}{cl}) = True}\\
\end{mathpar}

\framebox[1.2\width]{\separateIntersectionCast{c} = (c, c)}
\begin{mathpar}
\inferrule* []
{}
{\separateIntersectionCast{c : T_1 \Rightarrow^l T_2\ ^{cl}} = (\emptycast{T_1}{cl} : T_1 \Rightarrow^l T_2\ ^{cl}, c)}\\

\inferrule* []
{}
{\separateIntersectionCast{\emptycast{T}{cl}} = (\emptycast{T}{cl}, \emptycast{T}{cl})}\\
\end{mathpar}

\framebox[1.2\width]{\breakdownArrowType{c} = (c, c)}
\begin{mathpar}
\inferrule* []
{}
{\breakdownArrowType{\emptycast{T_{11} \rightarrow T_{12}}{cl} : T_{11} \rightarrow T_{12} \Rightarrow^l T_{21} \rightarrow T_{22}\ ^{cl}} =\\ (\emptycast{T_{21}}{cl} : T_{21} \Rightarrow^l T_{11}\ ^{cl}, \emptycast{T_{12}}{cl} : T_{12} \Rightarrow^l T_{22}\ ^{cl})}\\

\inferrule* []
{}
{\breakdownArrowType{\emptycast{T_1 \rightarrow T_2}{cl}} = (\emptycast{T_1}{cl}, \emptycast{T_2}{cl}})\\
\end{mathpar}

\framebox[1.2\width]{simulateArrow($c_1, \ldots, c_n$) = $((c_{11}, c_{12}, c_1^s), \ldots, (c_{m1}, c_{m2}, c_m^s))$}
\begin{mathpar}
\inferrule* []
{(c_1', \ldots, c_m') = filter\ isArrowCompatible\ (c_1, \ldots, c_n)\\
 ((c_1^f, c_1^s), \ldots, (c_m^f, c_m^s)) = map\ separateIntersectionCast\ (\assignCastLabel{c_1'}{0}, \ldots, \assignCastLabel{c_m'}{0})\\
 ((c_{11}, c_{12}), \ldots, (c_{m1}, c_{m2})) = map\ breakdownArrowType\ (\assignCastLabel{c_1^f}{1}, \ldots, \assignCastLabel{c_m^f}{m})}
{simulateArrow(c_1, \ldots, c_n) = ((c_{11}, c_{12}, c_1^s), \ldots, (c_{m1}, c_{m2}, c_m^s))}\\
\end{mathpar}
\hrulefill
\caption{Definitions for auxiliary semantic functions}
\label{definitions}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{getCastLabel(c) = cl}
\begin{mathpar}
\inferrule* []
{}
{getCastLabel(c : T_1 \Rightarrow^l T_2\ ^{cl}) = cl}\\

\inferrule* []
{}
{getCastLabel(\blamecast{T_I}{T_F}{l}{cl}) = cl}\\

\inferrule* []
{}
{getCastLabel(\emptycast{T}{cl}) = cl}\\
\end{mathpar}

\framebox[1.2\width]{sameCastLabel(c, c) = Bool}
\begin{mathpar}
\inferrule* []
{}
{sameCastLabel(c_1, c_2) = getCastLabel(c_1) == 0}\\
\inferrule* []
{}
{sameCastLabel(c_1, c_2) = getCastLabel(c_2) == 0}\\

\inferrule* []
{}
{sameCastLabel(c_1, c_2) = getCastLabel(c_1) == getCastLabel(c_2)}\\
\end{mathpar}
\framebox[1.2\width]{joinCasts(c, c) = c}
\begin{mathpar}
\inferrule* []
{}
{joinCasts(c : T_1 \Rightarrow^l T_2\ ^{cl}, c') = joinCasts(c, c') : T_1 \Rightarrow^l T_2\ ^{cl}}\\

\inferrule* []
{}
{joinCasts(\blamecast{T_I}{T_F}{l}{cl}, c) = \blamecast{T_I}{T_F}{l}{cl}}\\

\inferrule* []
{}
{getCastLabel(\emptycast{T}{cl}, c) = \assignCastLabel{c}{cl}}\\
\end{mathpar}

\framebox[1.2\width]{$\mergeCasts{e} = e$}
\begin{mathpar}
\inferrule* []
{(c_1', \ldots, c_o') = [joinCast\ y\ x\ |\ x \leftarrow (c_{11}, \ldots, c_{1m}),\ y \leftarrow (c_{21}, \ldots, c_{2n}),\\ sameCastLabel\ y\ x\ \&\&\ initialType(y) == finalType (x)]}
{\mergeCasts{e : c_{11} \cap \ldots \cap c_{1m} : c_{21} \cap \ldots \cap c_{2n}} = e : c_1' \cap \ldots \cap c_o'}\\
\end{mathpar}
\hrulefill
\caption{Definitions for auxiliary semantic functions}
\label{definitions2}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$\icts c : T$}\ Typing
\begin{mathpar}

\inferrule* [right=T-SingleIC]
{\icts c : T_1 \\ T_1 \sim T_2}
{\icts (c : T_1 \Rightarrow^l T_2\ ^{cl}) : T_2}

\inferrule* [right=T-BlameIC]
{ }
{\icts \blamecast{T_I}{T_F}{l}{cl} : T_F}

\inferrule* [right=T-EmptyIC]
{ }
{\icts \emptycast{T}{cl} : T}
\end{mathpar}
\hrulefill
\caption{Intersection Casts Type System ($\icts$)}
\label{intersection_casts_type_system}
\end{figure}

\begin{figure}[H]
\framebox[1.2\width]{$c \icos c$}\ Evaluation
\begin{mathpar}
Push\ blame\ to\ top\ level

\inferrule* [right=E-PushBlameIC]
{ }
{\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} \icos \blamecast{T_I}{T_2}{l_1}{cl_1}}

Evaluate\ inside\ casts\\

\inferrule* [right=E-EvaluateIC]
{\neg(is\ cast\ value\ c) \\ c \icos c'}
{c : T_1 \Rightarrow^l T_2\ ^{cl} \icos c' : T_1 \Rightarrow^l T_2\ ^{cl}}\\

Detect\ success\ or\ failure\ of\ casts\\

\inferrule* [right=E-IdentityIC]
{is\ cast\ value\ 1\ c \lor is\ empty\ cast\ c}
{c : T \Rightarrow^l T\ ^{cl} \icos c}

\inferrule* [right=E-SucceedIC]
{is\ cast\ value\ 1\ c \lor is\ empty\ cast\ c}
{c : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \icos c}

\inferrule* [right=E-FailIC]
{is\ cast\ value\ 1\ c \lor is\ empty\ cast\ c \\ \neg(same\ ground\ G_1\ G_2) \\ initialType(c) = T_I}
{c : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \icos \blamecast{T_I}{G_2}{l_2}{cl_1}}\\

Mediate\ the\ transition\ between\ the\ two\ disciplines

\inferrule* [right=E-GroundIC]
{is\ cast\ value\ 1\ c \lor is\ empty\ cast\ c \\ G\ is\ ground\ type\ of\ T \\ \neg(ground\ T)}
{c : T \Rightarrow^l \Dyn\ ^{cl} \icos c : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}}

\inferrule* [right=E-ExpandIC]
{is\ cast\ value\ 1\ c \lor is\ empty\ cast\ c \\ G\ is\ ground\ type\ of\ T \\ \neg(ground\ T)}
{c : \Dyn \Rightarrow^l T\ ^{cl} \icos c : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}}
\end{mathpar}
\hrulefill
\caption{Intersection Casts Semantics ($\icos$)}
\label{intersection_casts_semantics}
\end{figure}

\newpage

\section{Proofs}
\begin{lemma}[Consistency reduces to equality when comparing static types]
\label{consistencytoequality}
If $T_1$ and $T_2$ are static types then $T_1 = T_2 \iff T_1 \sim T_2$.
\end{lemma}
\begin{proof}
We proceed by structural induction on $T$.\\\\
Base cases:
\begin{itemize}
    \item $T_1 = \Int$.
    \begin{itemize}
        \item If $\Int = \Int$ then, by the definition of $\sim$, $\Int \sim \Int$.
        \item If $\Int \sim \Int$, then $\Int = \Int$.
    \end{itemize}
    \item $T_1 = \Bool$.
    \begin{itemize}
        \item If $\Bool = \Bool$ then, by the definition of $\sim$, $\Bool \sim \Bool$.
        \item If $\Bool \sim \Bool$, then $\Bool = \Bool$.
    \end{itemize}
\end{itemize}
Induction step:
\begin{itemize}
    \item $T_1 = T_{11} \rightarrow T_{12}$.
    \begin{itemize}
        \item If $T_{11} \rightarrow T_{12} = T_{21} \rightarrow T_{22}$, for some $T_{21}$ and $T_{22}$, then $T_{11} = T_{21}$ and $T_{12} = T_{22}$.
        By the induction hypothesis, $T_{11} \sim T_{21}$ and $T_{12} \sim T_{22}$.
        Therefore, by the definition of $\sim$, $T_{11} \rightarrow T_{12} \sim T_{21} \rightarrow T_{22}$.
        \item If $T_{11} \rightarrow T_{12} \sim T_2$, then by the definition of $\sim$, $T_2 = T_{21} \rightarrow T_{22}$ and $T_{11} \sim T_{21}$ and $T_{12} \sim T_{22}$.
        By the induction hypothesis, $T_{11} = T_{21}$ and $T_{12} = T_{22}$.
        Therefore, $T_{11} \rightarrow T_{12} = T_{21} \rightarrow T_{22}$.
    \end{itemize}
    \item $T_1 = T_{11} \cap \ldots \cap T_{1n}$.
    \begin{itemize}
        \item If $T_{11} \cap \ldots \cap T_{1n} = T_2$, then $\exists T_{21} \ldots T_{2n}\ .\ T_2 = T_{21} \cap \ldots \cap T_{2n}$ and $T_{11} = T_{21}$ and ... and $T_{1n} = T_{2n}$.
        By the induction hypothesis, $T_{11} \sim T_{21}$ and ... and $T_{1n} \sim T_{2n}$.
        Therefore, by the definition of $\sim$, $T_{11} \cap \ldots \cap T_{1n} \sim T_{21} \cap \ldots \cap T_{2n}$.
        \item If $T_{11} \cap \ldots \cap T_{1n} \sim T_2$, then either:
        \begin{itemize}
            \item $\exists T_{21} \ldots T_{2n}\ .\ T_2 = T_{21} \cap \ldots \cap T_{2n}$ and $T_{11} \sim T_{21}$ and ... and $T_{1n} \sim T_{2n}$.
            By the induction hypothesis, $T_{11} = T_{21}$ and ... and $T_{1n} = T_{2n}$.
            Therefore, $T_{11} \cap \ldots \cap T_{1n} = T_{21} \cap \ldots \cap T_{2n}$.
            \item $T_{11} \sim T_2$ and ... and $T_{1n} \sim T_2$.
            By the induction hypothesis, $T_{11} = T_2$ and ... and $T_{1n} = T_2$.
            As $T_2 \cap \ldots \cap T_2 = T_2$, then $T_{11} \cap \ldots \cap T_{1n} = T_2$.
        \end{itemize}
    \end{itemize}
\end{itemize}
\end{proof}

\begin{theorem}[Conservative Extension]
\label{conservative_extension_typesystem}
Depends on Lemma \ref{consistencytoequality}.
If e is fully static and T is a static type, then $\Gamma \sits e : T \iff \Gamma \gits e : T$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\sits$ and $\gits$ for the right and left direction of the implication, respectively.\\\\
Base case:
\begin{itemize}
    \item Rule T-Var.
    \begin{itemize}
        \item If $\Gamma \sits x : T$, then $x : T \in \Gamma$.
        Therefore, $\Gamma \gits x : T$.
        \item If $\Gamma \gits x : T$, then $x : T \in \Gamma$.
        Therefore, $\Gamma \sits e : T$.
    \end{itemize}
    \item Rule T-Int.
    \begin{itemize}
        \item If $\Gamma \sits n : \Int$, then $\Gamma \gits n : \Int$.
        \item If $\Gamma \gits n : \Int$, then $\Gamma \sits n : \Int$.
    \end{itemize}
    \item Rule T-True.
    \begin{itemize}
        \item If $\Gamma \sits \true : \Bool$, then $\Gamma \gits \true : \Bool$.
        \item If $\Gamma \gits \true : \Bool$, then $\Gamma \sits \true : \Bool$.
    \end{itemize}
    \item Rule T-False.
    \begin{itemize}
        \item If $\Gamma \sits \false : \Bool$, then $\Gamma \gits \false : \Bool$.
        \item If $\Gamma \gits \false : \Bool$, then $\Gamma \sits \false : \Bool$.
    \end{itemize}
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    \begin{itemize}
        \item If $\Gamma \sits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$, then $\Gamma, x : T_1 \cap \ldots \cap T_n \sits e : T$.
        By the induction hypothesis, $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$.
        Therefore, $\Gamma \gits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$.
        \item If $\Gamma \gits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$, then $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$.
        By the induction hypothesis, $\Gamma, x : T_1 \cap \ldots \cap T_n \sits e : T$.
        Therefore, $\Gamma \sits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$.
    \end{itemize}
    \item Rule T-Abs'.
    \begin{itemize}
        \item If $\Gamma \sits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$, then $\Gamma, x : T_i \sits e : T$.
        By the induction hypothesis, $\Gamma, x : T_i \gits e : T$.
        Therefore, $\Gamma \gits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$.
        \item If $\Gamma \gits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$, then $\Gamma, x : T_i \gits e : T$.
        By the induction hypothesis, $\Gamma, x : T_i \sits e : T$.
        Therefore, $\Gamma \sits \lambda x\ .\ T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$.
    \end{itemize}
    \item Rule T-App.
    \begin{itemize}
        \item If $\Gamma \sits e_1\ e_2 : T$ then $\Gamma \sits e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \sits e_2 : T_1 \cap \ldots \cap T_n$.
        By the induction hypothesis, $\Gamma \gits e_1\ : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \gits e_2 : T_1 \cap \ldots \cap T_n$.
        By the definition of $\rhd$, $T_1 \cap \ldots \cap T_n \rightarrow T \rhd T_1 \cap \ldots \cap T_n \rightarrow T$.
        By the definition of consistency ($T \sim T$), $T_1 \cap \ldots \cap T_n \sim T_1 \cap \ldots \cap T_n$.
        Therefore, $\Gamma \gits e_1\ e_2 : T$.
        \item If $\Gamma \gits e_1\ e_2 : T$ then $\Gamma \gits e_1 : PM$, $PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T$, $\Gamma \gits e_2 : T'_1 \cap \ldots \cap T'_n$ and $T'_1 \cap \ldots \cap T'_n \sim T_1 \cap \ldots \cap T_n$.
        By the definition of $\rhd$, $PM = T_1 \cap \ldots \cap T_n \rightarrow T$, therefore $\Gamma \gits e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$.
        By Lemma \ref{consistencytoequality}, $T'_1 \cap \ldots \cap T'_n = T_1 \cap \ldots \cap T_n$, and therefore $\Gamma \gits e_2 : T_1 \cap \ldots \cap T_n$.
        By the induction hypothesis, $\Gamma \sits e_1\ : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \sits e_2 : T_1 \cap \ldots \cap T_n$.
        Therefore, $\Gamma \sits e_1\ e_2 : T$.
    \end{itemize}
    \item Rule T-Gen.
    \begin{itemize}
        \item If $\Gamma \sits e : T_1 \cap \ldots \cap T_n$ then $\Gamma \sits e : T_1$ and ... and $\Gamma \sits e : T_n$.
        By the induction hypothesis, $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
        Therefore, $\Gamma \gits e : T_1 \cap \ldots \cap T_n$.
        \item If $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ then $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
        By the induction hypothesis, $\Gamma \sits e : T_1$ and ... and $\Gamma \sits e : T_n$.
        Therefore $\Gamma \sits e : T_1 \cap \ldots \cap T_n$.
    \end{itemize}
    \item Rule T-Inst.
    \begin{itemize}
        \item If $\Gamma \sits e : T_i$ then $\Gamma \sits e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, ..., T_n\}$.
        By the induction hypothesis, $\Gamma \gits e : T_1 \cap \ldots \cap T_n$.
        As $T_i \in \{T_1, ..., T_n\}$, then $\Gamma \gits e : T_i$.
        \item If $\Gamma \gits e : T_i$ then $\Gamma \gits e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, ..., T_n\}$.
        By the induction hypothesis, $\Gamma \sits e : T_1 \cap \ldots \cap T_n$.
        As $T_i \in \{T_1, ..., T_n\}$, then $\Gamma \sits e : T_i$.
    \end{itemize}
\end{itemize}
\end{proof}

\begin{theorem}[Monotonicity w.r.t. precision]
\label{monotonicity_wtr_precision}
If $\Gamma \gits e : T$ and $e' \sqsubseteq e$ then $\Gamma \gits e' : T'$ and $T' \sqsubseteq T$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\Gamma \gits e : T$.\\\\
Base case:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \gits x : T$ and $x \sqsubseteq x$, then $\Gamma \gits x : T$ and $T \sqsubseteq T$.
    \item Rule T-Int.
    If $\Gamma \gits n : \Int$ and $n \sqsubseteq n$, then $\Gamma \gits n : \Int$ and $\Int \sqsubseteq \Int$.
    \item Rule T-True.
    If $\Gamma \gits \true : \Bool$ and $\true \sqsubseteq \true$, then $\Gamma \gits \true : \Bool$ and $\Bool \sqsubseteq \Bool$.
    \item Rule T-False.
    If $\Gamma \gits \false : \Bool$ and $\false \sqsubseteq \false$, then $\Gamma \gits \false : \Bool$ and $\Bool \sqsubseteq \Bool$.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' \sqsubseteq \lambda x : T_1 \cap \ldots \cap T_n\ .\ e$, then $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$, $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$ and $e' \sqsubseteq e$.
    By the induction hypothesis, $\Gamma, x : T_1' \cap \ldots \cap T_n' \gits e' : T'$ and $T' \sqsubseteq T$.
    As $\Gamma \gits \lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' : T_1' \cap \ldots \cap T_n' \rightarrow T'$, and by the definition of $\sqsubseteq$, $T_1' \cap \ldots \cap T_n' \rightarrow T' \sqsubseteq T_1 \cap \ldots \cap T_n \rightarrow T$, then it is proved.
    \item Rule T-Abs'.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$ and $\lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' \sqsubseteq \lambda x : T_1 \cap \ldots \cap T_n\ .\ e$, then $\Gamma, x : T_i \gits e : T$, $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$ and $e' \sqsubseteq e$.
    By the induction hypothesis, $\Gamma, x : T_i' \gits e' : T'$ and $T' \sqsubseteq T$.
    As $\Gamma \gits \lambda x : T_1' \cap \ldots \cap T_n'\ .\ e' : T_i' \rightarrow T'$, and by the definition of $\sqsubseteq$, $T_i' \rightarrow T' \sqsubseteq T_i \rightarrow T$, then it is proved.
    \item Rule T-App.
    If $\Gamma \gits e_1\ e_2 : T$ and $e_1'\ e_2' \sqsubseteq e_1\ e_2$ then $\Gamma \gits e_1 : PM$, $PM \rhd T_{11} \cap \ldots \cap T_{1n} \rightarrow T$, $\Gamma \gits e_2 : T_{21} \cap \ldots \cap T_{2n}$, and $T_{21} \cap \ldots \cap T_{2n} \sim T_{11} \cap \ldots \cap T_{1n}$, $e_1' \sqsubseteq e_1$ and $e_2' \sqsubseteq e_2$.
    By the induction hypothesis, $\Gamma \gits e_1' : PM'\ and\ PM' \sqsubseteq PM\ and\ PM' \rhd T_{11}' \cap \ldots \cap T_{1n}' \rightarrow T'$ and $\Gamma \gits e_2' : T_{21}' \cap \ldots \cap T_{2n}'\ and\ T_{21}' \cap \ldots \cap T_{2n}' \sqsubseteq T_{21} \cap \ldots \cap T_{2n}\ and\ T_{21}' \cap \ldots \cap T_{2n}' \sim T_{11}' \cap \ldots \cap T_{1n}'$.
    By the definition of $\sqsubseteq$ and $\rhd$, $T_{11}' \cap \ldots \cap T_{1n}' \rightarrow T' \sqsubseteq T_{11} \cap \ldots \cap T_{1n} \rightarrow T$, and therefore, $T' \sqsubseteq T$.
    As $\Gamma \gits e_1'\ e_2' : T'$, it is proved.
    \item Rule T-Gen.
    If $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ and $e' \sqsubseteq e$, then $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
    By the induction hypothesis, $\Gamma \gits e' : T_1'\ and\ T_1' \sqsubseteq T_1$ and ... and $\Gamma \gits e' : T_n'\ and\ T_n' \sqsubseteq T_n$.
    Then, $\Gamma \gits e' : T_1' \cap \ldots \cap T_n'$ and by the definition of $\sqsubseteq$, $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$, then it is proved.
    \item Rule T-Inst.
    If $\Gamma \gits e : T_i$ and $e' \sqsubseteq e$, then $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ such that $T_i \in \{T_1, ..., T_n\}$.
    By the induction hypothesis, $\Gamma \gits e' : T_1' \cap \ldots \cap T_n'$ and $T_1' \cap \ldots \cap T_n' \sqsubseteq T_1 \cap \ldots \cap T_n$.
    Therefore, $\Gamma \gits e' : T_i'$ and by the definition of $\sqsubseteq$, $T_i' \sqsubseteq T_i$, then it is proved.
\end{itemize}
\end{proof}

\begin{theorem}[Type preservation of cast insertion]
\label{type_preservation_cast_insertion}
If $\Gamma \gits e : T$ then $\Gamma \iccts e \leadsto e' : T$ and $\Gamma \iccts e' : T$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\Gamma \gits e : T$.\\\\
Base case:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \gits x : T$ then $x : T \in \Gamma$.
    As $\Gamma \iccts x \leadsto x : T$ and $\Gamma \iccts x : T$, it is proved.
    \item Rule T-Int.
    As $\Gamma \gits n : \Int$, $\Gamma \iccts n \leadsto n : \Int$ and $\Gamma \iccts n : \Int$, it is proved.
    \item Rule T-True.
    As $\Gamma \gits \true : \Bool$, $\Gamma \iccts \true \leadsto \true : \Bool$ and $\Gamma \iccts \true : \Bool$, it is proved.
    \item Rule T-False.
    As $\Gamma \gits \false : \Bool$, $\Gamma \iccts \false \leadsto \false : \Bool$ and $\Gamma \iccts \false : \Bool$, it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ then $\Gamma, x : T_1 \cap \ldots \cap T_n \gits e : T$.
    By the induction hypothesis, $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e \leadsto e' : T$ and $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e' : T$.
    As $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e \leadsto \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_1 \cap \ldots \cap T_n \rightarrow T$, it is proved.
    \item Rule T-Abs'.
    If $\Gamma \gits \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$ then $\Gamma, x : T_i \gits e : T$.
    By the induction hypothesis, $\Gamma, x : T_i \iccts e \leadsto e' : T$ and $\Gamma, x : T_i \iccts e' : T$.
    As $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e \leadsto \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_i \rightarrow T$ and $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e' : T_i \rightarrow T$, it is proved.
    \item Rule T-App.
    If $\Gamma \gits e_1\ e_2 : T$ then $\Gamma \gits e_1 : PM$, $PM \rhd T_1 \cap \ldots \cap T_n \rightarrow T$, $\Gamma \gits e_2 : T_1' \cap \ldots \cap T_n'$ and $T_1' \cap \ldots \cap T_n' \sim T_1 \cap \ldots \cap T_n$.
    By the induction hypothesis, $\Gamma \iccts e_1 \leadsto e_1' : PM$ and $\Gamma \iccts e_1' : PM$, and $\Gamma \iccts e_2 \leadsto e_2' : T_1' \cap \ldots \cap T_n'$ and $\Gamma \iccts e_2' : T_1' \cap \ldots \cap T_n'$.
    Therefore, $\Gamma \iccts e_1\ e_2 \leadsto e_1''\ e_2'' : T$.
    By the definition of $instances$ and $S,\ S,\ e \hookrightarrow e$, we have $\Gamma \iccts e_1'' : T_1 \rightarrow T \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2'' : T_1 \cap \ldots \cap T_n$.
    As $\Gamma \iccts e_1''\ e_2'' : T \cap \ldots \cap T$ then $\Gamma \iccts e_1''\ e_2'' : T$.
    \item Rule T-Gen.
    If $\Gamma \gits e : T_1 \cap \ldots \cap T_n$ then $\Gamma \gits e : T_1$ and ... and $\Gamma \gits e : T_n$.
    By the induction hypothesis, $\Gamma \iccts e \leadsto e' : T_1$ and ... and $\Gamma \iccts e \leadsto e' : T_n$, and $\Gamma \iccts e' : T_1$ and ... and $\Gamma \iccts e' : T_n$.
    Therefore, $\Gamma \iccts e \leadsto e' : T_1 \cap \ldots \cap T_n$ and $\Gamma \iccts e' : T_1 \cap \ldots \cap T_n$.
    \item Rule T-Inst.
    If $\Gamma \gits e : T_i$ then $\Gamma \gits e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, \ldots, T_n\}$.
    By the induction hypothesis, $\Gamma \iccts e \leadsto e' : T_1 \cap \ldots \cap T_n$ and $\Gamma \iccts e' : T_1 \cap \ldots \cap T_n$.
    Therefore, $\Gamma \iccts e \leadsto e' : T_i$ and $\Gamma \iccts e' : T_i$.
\end{itemize}
\end{proof}

\begin{theorem}[Monotonicity of cast insertion]
\label{monotonicity_cast_insertion}
If $\Gamma \iccts e_1 \leadsto e_1' : T$ and $\Gamma \iccts e_2 \leadsto e_2' : T$ and $e_1 \sqsubseteq e_2$ then $e_1' \sqsubseteq e_2'$.
\end{theorem}

\begin{theorem}[Conservative Extension]
\label{conservative_extension_operationalsemantics}
If e is fully static, then $e \sios e' \iff e \gios e'$.
\end{theorem}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\sios$ and $\gios$ for the right and left direction of the implication, respectively.
Base case:
\begin{itemize}
    \item Rule E-AppAbs.
    If $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \sios [x \mapsto v]e$ and $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \gios [x \mapsto v]e$, then it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule E-App1.
    \begin{itemize}
        \item If $e_1\ e_2 \sios e_1'\ e_2$ then $e_1 \sios e_1'$.
        By the induction hypothesis, $e_1 \gios e_1'$.
        Therefore, $e_1\ e_2 \gios e_1'\ e_2$
        \item If $e_1\ e_2 \gios e_1'\ e_2$ then $e_1 \gios e_1'$.
        By the induction hypothesis, $e_1 \sios e_1'$.
        Therefore, $e_1\ e_2 \sios e_1'\ e_2$
    \end{itemize}
    \item Rule E-App2.
    \begin{itemize}
        \item If $v_1\ e_2 \sios v_1\ e_2'$ then $e_2 \sios e_2'$.
        By the induction hypothesis, $e_2 \gios e_2'$.
        Therefore, $v_1\ e_2 \gios v_1\ e_2'$
        \item If $v_1\ e_2 \gios v_1\ e_2'$ then $e_2 \gios e_2'$.
        By the induction hypothesis, $e_2 \sios e_2'$.
        Therefore, $v_1\ e_2 \sios v_1\ e_2'$
    \end{itemize}
\end{itemize}
\end{proof}

\begin{lemma}[Type preservation of $\icos$]
\label{typepreservationIC}
If $c \icos c$ and
\begin{itemize}
    \item $\icts c : T$ then $\icts c' : T$.
    \item $initialType(c) = T$ then $initialType(c') = T$.
\end{itemize}
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\icos$.\\\\
Base cases:
\begin{itemize}
    \item Rule E-PushBlameIC.
    \begin{itemize}
        \item $\icts \blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} : T_2$ and by rule E-PushBlameIC, $\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} \icos \blamecast{T_I}{T_2}{l_1}{cl_1}$.
        As $\icts \blamecast{T_I}{T_2}{l_1}{cl_1} : T_2$, then it is proved.
        \item By the definition of $initialType$, $initialType(\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2}) = T_I$.
        By rule E-PushBlameIC, $\blamecast{T_I}{T_F}{l_1}{cl_1} : T_1 \Rightarrow^{l_2} T_2\ ^{cl_2} \icos \blamecast{T_I}{T_2}{l_1}{cl_1}$.
        Since $initialType(\blamecast{T_I}{T_2}{l_1}{cl_1}) = T_I$, it is proved.
    \end{itemize}
    \item Rule E-IdentityIC.
    \begin{itemize}
        \item If $\icts c : T \Rightarrow^l T\ ^{cl} : T$, then $\icts c : T$.
        By rule E-IdentityIC, $c : T \Rightarrow^l T\ ^{cl} \icos c$.
        Therefore it is proved.
        \item By the definitions of $initialType$, $initialType(c : T \Rightarrow^l T\ ^{cl}) = initialType(c)$.
        By rule E-IdentityIC, $c : T \Rightarrow^l T\ ^{cl} \icos c$.
        Therefore it is proved.
    \end{itemize}
    \item Rule E-SucceedIC.
    \begin{itemize}
        \item If $\icts c : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} : G$, then $\icts c : G$.
        By rule E-SucceedIC, $c : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \icos c$.
        Therefore it is proved.
        \item Rule E-SucceedIC.
        By the definition of $initialType$, $initialType(c : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2}) = initialType(c)$.
        By rule E-SucceedIC, $c : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \icos c$.
        Therefore it is proved.
    \end{itemize}
    \item Rule E-FailIC.
    \begin{itemize}
        \item If $\icts c : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} : G_2$, and by rule E-FailIC, $c : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \icos \blamecast{T_I}{G_2}{l_2}{cl_1}$ and $\icts \blamecast{T_I}{G_2}{l_2}{cl_1} : G_2$, it is proved.
        \item By the definition of $initialType$, $initialType(c : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2}) = T_I$.
        By rule E-FailIC, $c : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \icos \blamecast{T_I}{G_2}{l_2}{cl_1}$.
        Since $initialType(\blamecast{T_I}{G_2}{l_2}{cl_1}) = T_I$, it is proved.
    \end{itemize}
    \item Rule E-GroundIC.
    \begin{itemize}
        \item If $\icts c : T \Rightarrow^l \Dyn\ ^{cl} : \Dyn$ then $\icts c : T$.
        By rule E-GroundIC, $c : T \Rightarrow^l \Dyn\ ^{cl} \icos c : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}$.
        As $\icts c : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl} : \Dyn$, it is proved.
        \item By the definition of $initialType$, $initialType(c : T \Rightarrow^l \Dyn\ ^{cl}) = initialType(c)$.
        By rule E-GroundIC, $c : T \Rightarrow^l \Dyn\ ^{cl} \icos c : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}$.
        Since $initialType(c : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}) = initialType(c)$, it is proved.
    \end{itemize}
    \item Rule E-ExpandIC.
    \begin{itemize}
        \item If $\icts c : \Dyn \Rightarrow^l T\ ^{cl} : T$ then $\icts c : \Dyn$.
        By rule E-ExpandIC, $c : \Dyn \Rightarrow^l T\ ^{cl} \icos c : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}$.
        As $\icts c : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl} : T$, it is proved.
        \item By the definition of $initialType$, $initialType(c : \Dyn \Rightarrow^l T\ ^{cl}) = initialType(c)$.
        By rule E-ExpandIC, $c : \Dyn \Rightarrow^l T\ ^{cl} \icos c : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}$.
        Since $initialType(c : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}) = initialType(c)$, it is proved.
    \end{itemize}
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule E-EvaluateIC.
    \begin{itemize}
        \item If $\icts c : T_1 \Rightarrow^l T_2\ ^{cl} : T_2$ then $\icts c : T_1$.
        By rule E-EvaluateIC, $c \icos c'$.
        By the induction hypothesis, $\icts c' : T_1$.
        By rule E-EvaluateIC, $c : T_1 \Rightarrow^l T_2\ ^{cl} \icos c' : T_1 \Rightarrow^l T_2\ ^{cl}$.
        As $\icts c' : T_1 \Rightarrow^l T_2\ ^{cl} : T_2$ it is proved.
        \item By the definition of $initialType$, $initialType(c : T_1 \Rightarrow^l T_2\ ^{cl}) = initialType(c)$.
        By rule E-EvaluateIC, $c \icos c'$.
        By the induction hypothesis, $initialType(c') = initialType(c)$.
        By rule E-EvaluateIC, $c : T_1 \Rightarrow^l T_2\ ^{cl} \icos c' : T_1 \Rightarrow^l T_2\ ^{cl}$.
        Since $initialType(c' : T_1 \Rightarrow^l T_2\ ^{cl}) = initialType(c')$, it is proved.
    \end{itemize}
\end{itemize}
\end{proof}

\begin{lemma}[Progress of $\icos$]
\label{progressIC}
If $\Gamma \icts c : T$ and $initialType(c) = T_I$ then either $c$ is a cast value or there exists a $c'$ such that $c \icos c'$.
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\icts c : T$.\\\\
Base case:
\begin{itemize}
    \item Rule T-BlameIC.
    As $\icts \blamecast{T_I}{T_F}{l}{cl} : T_F$, $initialType(\blamecast{T_I}{T_F}{l}{cl}) = T_I$ and $\blamecast{T_I}{T_F}{l}{cl}$ is a cast value, it is proved.
    \item Rule T-EmptyIC.
    As $\icts \emptycast{T}{cl} : T$, $initialType(\emptycast{T}{cl}) = T$ and $\emptycast{T}{cl}$ is a cast value, it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-SingleIC.
    If $\icts c : T_1 \Rightarrow^l T_2\ ^cl : T_2$ and $initialType(c : T_1 \Rightarrow^l T_2\ ^cl) = T_I$ then $\icts c : T_1$ and $initialType(c) = T_I$.
    By the induction hypothesis, either $c$ is a cast value or there is a $c'$ such that $c \icos c'$.
    If $c$ is a cast value, then $c$ can either be of the form $\blamecast{T_I}{T_F}{l}{cl}$, in which case by rule E-PushBlameIC, $\blamecast{T_I}{T_F}{l}{cl} : T_1 \Rightarrow^l T_2\ ^cl \icos \blamecast{T_I}{T_2}{l}{cl}$ or $c$ is a cast value 1 or is an empty cast.
    If $c$ is a cast value 1 or is an empty cast then $c : T_1 \Rightarrow^l T_2\ ^cl$ can be of one of the folowing forms:
    \begin{itemize}
        \item $c : T \Rightarrow^l T\ ^{cl}$. Then by rule E-IdentityIC, $c : T \Rightarrow^l T\ ^{cl} \icos c$.
        \item $c : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2}$. Then by rule E-SucceedIC, $c : G \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G\ ^{cl_2} \icos c$.
        \item $c : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2}$. Then by rule E-FailIC, $c : G_1 \Rightarrow^{l_1} \Dyn\ ^{cl_1} : \Dyn \Rightarrow^{l_2} G_2\ ^{cl_2} \icos \blamecast{T_I}{G_2}{l_2}{cl_1}$.
        \item $c : T \Rightarrow^l \Dyn\ ^{cl}$. Then by rule E-GroundIC, $c : T \Rightarrow^l \Dyn\ ^{cl} \icos c : T \Rightarrow^l G\ ^{cl} : G \Rightarrow^l \Dyn\ ^{cl}$.
        \item $c : \Dyn \Rightarrow^l T\ ^{cl}$. Then by rule E-ExpandIC, $c : \Dyn \Rightarrow^l T\ ^{cl} \icos c : \Dyn \Rightarrow^l G\ ^{cl} : G \Rightarrow^l T\ ^{cl}$.
    \end{itemize}
    If there is a $c'$ such that $c \icos c'$, then by rule E-EvaluateIC, $c : T_1 \Rightarrow^l T_2\ ^cl \icos c' : T_1 \Rightarrow^l T_2\ ^cl$.
\end{itemize}
\end{proof}

\begin{lemma}[Type preservation of $\gios$]
\label{typepreservation}
Depends on Lemmas \ref{typepreservationIC} and \ref{progressIC}.
If $\Gamma \iccts e : T$ and $e \gios e'$ then $\Gamma \iccts e' : T$.
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\gios$.\\\\
Base case:
\begin{itemize}
    \item Rule E-AppAbs.
    There exists a type $T_1 \cap \ldots \cap T_n$ such that we can deduce $\Gamma \iccts (\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v : T$ from $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts v : T_1 \cap \ldots \cap T_n$ ($x$ does not occur in $\Gamma$).
    Moreover, $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ only if $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e : T$.
    By rule E-AppAbs, $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ v \gios [x \mapsto v] e$.
    To obtain $\Gamma \iccts [x \mapsto v] e : T$, it is sufficient to replace, in the proof of $\Gamma, x : T_1 \cap \ldots \cap T_n \iccts e : T$, the statements $x : T_i$ (introduzed by the rules T-Var and T-Inst) by the deductions of $\Gamma \iccts v : T_i$ for $1 \leq i \leq n$.
    (Proof adapted from \cite{coppo1980extension})
    \item Rule E-SimulateArrow.
    If $\Gamma \iccts (v_1 : cv_1 \cap \ldots \cap cv_n)\ v_2 : T_{12} \cap \ldots \cap T_{n2}$, then $\Gamma \iccts v_1 : cv_1 \cap \ldots \cap cv_n : T_1 \cap \ldots \cap T_n$ with $\icts cv_1 : T_1$ and ... and $\icts cv_n : T_n$, such that $\exists i \in 1 .. n\ .\ T_i = T_{i1} \rightarrow T_{i2}$ and $\Gamma \iccts v_1 : T_1' \cap \ldots \cap T_l'$ and $I_1 = initialType(cv_1)$ and ... and $I_n = initialType(cv_n)$ such that either $T_1' \cap \ldots \cap T_l' = I_1 \cap \ldots \cap I_n$ or $\{I_1, \ldots, I_n\} \subset \{T_1', \ldots, T_l'\}$ and $\Gamma \iccts v_2 : T_{11} \cap \ldots \cap T_{n1}$.
    For the sake of simplicity lets elide cast labels and blame labels.
    By the definition of SimulateArrow, we have that $c_1' = c_1'' : T_{11}' \rightarrow T_{12}' \Rightarrow T_{11} \rightarrow T_{12}$ and ... and $c_m' = c_m'' : T_{m1}' \rightarrow T_{m2}' \Rightarrow T_{m1} \rightarrow T_{m2}$.
    Also, $c_{11} = \emptycast{T_{11}}{} : T_{11} \Rightarrow T_{11}'$ and ... and $c_{m1} = \emptycast{T_{m1}}{} : T_{m1} \Rightarrow T_{m1}'$ and $c_{12} : \emptycast{T_{12}'}{} : T_{12}' \Rightarrow T_{12}$ and ... and $c_{m2} = \emptycast{T_{m2}'}{} : T_{m2}' \Rightarrow T_{m2}$ and $initialType(c^s_1) = I_1$ and ... and $initialType(c^s_m) = I_m$ and $\icts c^s_1 : T_{11}' \rightarrow T_{12}'$ and ... and $\icts c^s_m : T_{m1}' \rightarrow T_{m2}'$.
    Therefore $\Gamma \iccts v_1 : c^s_1 \cap \ldots \cap c^s_m : T_{11}' \rightarrow T_{12}' \cap \ldots \cap T_{m1}' \rightarrow T_{m2}'$ and $\Gamma \iccts v_2 : c_{11} \cap \ldots \cap c_{m1} : T_{11}' \cap \ldots \cap T_{m1}'$ and therefore $\Gamma \iccts (v_1 : c^s_1 \cap \ldots \cap c c^s_m)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : T_{12}' \cap \ldots \cap T_{m2}'$.
    Therefore, $\Gamma \iccts (v_1 : c^s_1 \cap \ldots \cap c^s_m)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : c_{12} \cap \ldots \cap c_{m2} : T_{12} \cap \ldots \cap T_{m2}$, such that $\{T_{12}, \ldots, T_{m2}\} \subset \{T_{12}, \ldots, T_{n2}\}$.
    By rule E-SimulateArrow, $(v_1 : cv_1 \cap \ldots \cap cv_n)\ v_2 \gios\\ (v_1 : c^s_1 \cap \ldots \cap c^s_m)\ (v_2 : c_{11} \cap \ldots \cap c_{m1}) : c_{12} \cap \ldots \cap c_{m2}$, therefore it is proved.
    \item Rule E-MergeCasts.
    If $\Gamma \iccts v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m' : F_1' \cap \ldots \cap F_m'$ then $\icts c_1' : F_1'$ and $initialType(c_1') = I_1'$ and ... and $\icts c_m' : F_m'$ and $initialType(c_m') = I_m'$ and $\Gamma \iccts v : cv_1 \cap \ldots \cap cv_n : F_1 \cap \ldots \cap F_n$ and $\icts cv_1 : F_1$ and $initialType(cv_1) = I_1$ and ... and $\icts cv_n : F_n$ and $initialType(cv_n) = I_n$ and $\Gamma \iccts v : T_1 \cap \ldots \cap T_l$ such that either $T_1 \cap \ldots \cap T_l = I_1 \cap \ldots \cap I_n$ or $\{I_1, \ldots, I_n\} \subset \{T_1, \ldots, T_l\}$.
    There are two possibilities:
    \begin{itemize}
        \item $F_1 \cap \ldots \cap F_n = I_1' \cap \ldots \cap I_m'$.
        By the definition of mergeCasts, $\icts c_1'' : F_1''$ and ... and $\icts c_j'' : F_j''$ such that $F_1'' \cap \ldots \cap F_j'' = F_1' \cap \ldots \cap F_m'$ and $initialType(c_1'') = I_1''$ and ... and $initialType(c_j'') = I_j''$ such that $I_1'' \cap \ldots \cap I_j'' = I_1 \cap \ldots \cap I_n$.
        Therefore $\Gamma \iccts v : c_1'' \cap \ldots \cap c_j'' : F_1'' \cap \ldots \cap F_j''$.
        By rule E-MergeCasts, $v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m' \gios v : c_1'' \cap \ldots \cap c_j''$.
        Therefore it is proved.
        \item $\{I_1', \ldots, I_m'\} \subset \{F_1, \ldots, F_n\}$.
        By the definition of mergeCasts, $\icts c_1'' : F_1''$ and $initialType(c_1'') = I_1''$ and ... and $\icts c_j'' : F_j''$ and $initialType(c_j'') = I_j''$ such that $\{I_1'', \ldots, I_j''\} \subset \{I_1, \ldots, I_n\}$ and $\{F_1'', \ldots, F_j''\} \subset \{F_1', \ldots, F_m'\}$.
        Therefore, $\Gamma \iccts v : c_1'' \cap \ldots \cap c_j'' : F_1'' \cap \ldots \cap F_j''$.
        By rule E-MergeCasts, $v : cv_1 \cap \ldots \cap cv_n : c_1' \cap \ldots \cap c_m' \gios v : c_1'' \cap \ldots \cap c_j''$.
        Therefore, it is proved.
    \end{itemize}
    \item Rule E-EvaluateCasts.
    If $\Gamma \iccts v : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$ then $\icts c_1 : T_1$ and $I_1 = initialType(c_1)$ and ... and $\icts c_n : T_n$ and $I_n = initialType(c_n)$ and $\Gamma \iccts v : I_1 \cap \ldots \cap I_n$.
    By rule E-EvaluateCasts, $c_1 \icos cv_1$ and ... and $c_n \icos cv_n$.
    By Lemmas \ref{typepreservationIC} and \ref{progressIC}, $\icts cv_1 : T_1$ and $initialType(cv_1) = I_1$ and ... and $\icts cv_n : T_n$ and $initialType(cv_n) = I_n$.
    Therefore $\Gamma \iccts v : cv_1 \cap \ldots \cap cv_n : T_1 \cap \ldots \cap T_n$.
    By rule E-EvaluateCasts, $v : c_1 \cap \ldots \cap c_n \gios v : cv_1 \cap \ldots \cap cv_n$, then it is proved.
    \item Rule E-PropagateBlame.
    If $\Gamma \iccts v : \blamecast{T_1'}{T_1}{l_1}{m_1} \cap \ldots \cap \blamecast{T_n'}{T_n}{l_n}{m_n} : T_1 \cap \ldots \cap T_n$ and by rule E-PropagateBlame $v : \blamecast{T_1'}{T_1}{l_1}{m_1} \cap \ldots \cap \blamecast{T_n'}{T_n}{l_n}{m_n} \gios \blame{(T_1 \cap \ldots \cap T_n)}{l_1}$, and $\Gamma \iccts \blame{(T_1 \cap \ldots \cap T_n)}{l_1} : T_1 \cap \ldots \cap T_n$, then it is proved.
    \item Rule E-RemoveEmpty.
    If $\Gamma \iccts v : \emptycast{T_1}{m_1} \cap \ldots \cap \emptycast{T_n}{m_n} : T_1 \cap \ldots \cap T_n$, then $\icts \emptycast{T_1}{m_1} : T_1$ and $initialType(\emptycast{T_1}{m_1}) = T_1$ and ... and $\icts \emptycast{T_n}{m_n} : T_n$ and $initialType(\emptycast{T_n}{m_n}) = T_n$ and $\Gamma \iccts v : T_1 \cap \ldots \cap T_n$.
    By rule E-RemoveEmpty, $v : \emptycast{T_1}{m_1} \cap \ldots \cap \emptycast{T_n}{m_n} \gios v$, therefore it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule E-App1. There are two possibilities:
    \begin{itemize}
        \item If $\Gamma \iccts e_1\ e_2 : T$, then $\Gamma \iccts e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2 : T_1 \cap \ldots \cap T_n$.
        By rule E-App1, $e_1 \icos e_1'$, so by the induction hypothesis, $\Gamma \iccts e_1' : T_1 \cap \ldots \cap T_n \rightarrow T$.
        Therefore, $\Gamma \iccts e_1'\ e_2 : T$.
        As by rule E-App1, $e_1\ e_2 \icos e_1'\ e_2$, it is proved.
        \item If $\Gamma \iccts e_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}$, then $\Gamma \iccts e_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$ and $\Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}$.
        By rule E-App1, $e_1 \icos e_1'$, so by the induction hypothesis, $\Gamma \iccts e_1' : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$.
        Therefore, $\Gamma \iccts e_1'\ e_2 : T_{12} \cap \dots \cap T_{n2}$.
        As by rule E-App1, $e_1\ e_2 \icos e_1'\ e_2$, it is proved.
    \end{itemize}
    \item Rule E-App2. There are two possibilities:
    \begin{itemize}
        \item If $\Gamma \iccts v_1\ e_2 : T$, then $\Gamma \iccts v_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2 : T_1 \cap \ldots \cap T_n$.
        By rule E-App2, $e_2 \icos e_2'$, so by the induction hypothesis, $\Gamma \iccts e_2' : T_1 \cap \ldots \cap T_n$.
        Therefore, $\Gamma \iccts v_1\ e_2' : T$.
        As by rule E-App2, $v_1\ e_2 \icos v_1\ e_2'$, it is proved.
        \item If $\Gamma \iccts v_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}$, then $\Gamma \iccts v_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$ and $\Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}$.
        By rule E-App2, $e_2 \icos e_2'$, so by the induction hypothesis, $\Gamma \iccts e_2' : T_{11} \cap \ldots \cap T_{n1}$.
        Therefore, $\Gamma \iccts v_1\ e_2' : T_{12} \cap \dots \cap T_{n2}$.
        As by rule E-App1, $v_1\ e_2 \icos v_1\ e_2'$, it is proved.
    \end{itemize}
    \item Rule E-Evaluate. If $\Gamma \iccts e : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$, then $\Gamma \iccts e : T$, $\icts c_1 : T_1$ and ... and $\icts c_n : T_n$ and $initialType(c_1) \cap \ldots \cap initialType(c_n) = T$.
    By rule E-Evaluate, $e \icos e'$, so by the induction hypothesis, $\Gamma \iccts e' : T$.
    Therefore, $\Gamma \iccts e' : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$.
    As by rule E-Evaluate, $e : c_1 \cap \ldots \cap c_n \icos e' : c_1 \cap \ldots \cap c_n$, it is proved.
\end{itemize}
\end{proof}

\begin{lemma}[Progress of $\gios$]
\label{progress}
If $\Gamma \iccts e : T$ then either $e$ is a value or there exists an $e'$ such that $e \gios e'$.
\end{lemma}
\begin{proof}
We proceed by induction on the length of the derivation tree of $\Gamma \gits e : T$.\\\\
Base case:
\begin{itemize}
    \item Rule T-Var.
    If $\Gamma \iccts x : T$, then $x : T \in \Gamma$. As $x$ is a value, it is proved.
    \item Rule T-Int.
    As $\Gamma \iccts n : \Int$ and $n$ is a value, it is proved.
    \item Rule T-True.
    As $\Gamma \iccts \true : \Bool$ and $\true$ is a value, it is proved.
    \item Rule T-False.
    As $\Gamma \iccts \false : \Bool$ and $\false$ is a value, it is proved.
\end{itemize}
Induction step:
\begin{itemize}
    \item Rule T-Abs.
    As $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\lambda x : T_1 \cap \ldots \cap T_n\ .\ e$ is a value, it is proved.
    \item Rule T-Abs'.
    As $\Gamma \iccts \lambda x : T_1 \cap \ldots \cap T_n\ .\ e : T_i \rightarrow T$ such that $T_i \in \{T_1, \ldots, T_n\}$ and $\lambda x : T_1 \cap \ldots \cap T_n\ .\ e$ is a value, it is proved.
    \item Rule T-App.
    If $\Gamma \iccts e_1\ e_2 : T$, then $\Gamma \iccts e_1 : T_1 \cap \ldots \cap T_n \rightarrow T$ and $\Gamma \iccts e_2 : T_1 \cap \ldots \cap T_n$.
    By the induction hypothesis, $e_1$ is either a value or there is a $e_1'$ such that $e_1 \gios e_1'$ and $e_2$ is either a value or there is a $e_2'$ such that $e_2 \gios e_2'$.
    If $e_1$ is not a value, then by rule E-App1, $e_1\ e_2 \gios e_1'\ e_2$.
    If $e_1$ is a value and $e_2$ is not a value, then by rule E-App2, $e_1\ e_2 \gios e_1\ e_2'$.
    If both $e_1$ and $e_2$ are values then $e_1$ must be an abstraction $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)$, and by rule E-AppAbs $(\lambda x : T_1 \cap \ldots \cap T_n\ .\ e)\ e_2 \gios [x \mapsto e_2]e$.
    \item Rule T-Gen.
    If $\Gamma \iccts e : T_1 \cap \ldots \cap T_n$, then $\Gamma \iccts e : T_1$ and ... and $\Gamma \iccts e : T_n$.
    By the induction hypothesis, either $e$ is a value or there exists an $e'$ such that $e \gios e'$.
    \item Rule T-Inst.
    If $\Gamma \iccts e : T_i$, then $\Gamma \iccts e : T_1 \cap \ldots \cap T_n$, such that $T_i \in \{T_1, \ldots, T_n\}$.
    By the induction hypothesis, either $e$ is a value or there exists an $e'$ such that $e \gios e'$.
    \item Rule T-App'.
    If $\Gamma \iccts e_1\ e_2 : T_{12} \cap \ldots \cap T_{n2}$, then $\Gamma \iccts e_1 : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}$ and $\Gamma \iccts e_2 : T_{11} \cap \ldots \cap T_{n1}$.
    By the induction hypothesis, $e_1$ is either a value or there is a $e_1'$ such that $e_1 \gios e_1'$ and $e_2$ is either a value or there is a $e_2'$ such that $e_2 \gios e_2'$.
    If $e_1$ is not a value, then by rule E-App1, $e_1\ e_2 \gios e_1'\ e_2$.
    If $e_1$ is a value and $e_2$ is not a value, then by rule E-App2, $e_1\ e_2 \gios e_1\ e_2'$.
    If both $e_1$ and $e_2$ are values then $e_1$ must be an abstraction $(\lambda x : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2} .\ e)$, and by rule E-AppAbs $(\lambda x : T_{11} \rightarrow T_{12} \cap \ldots \cap T_{n1} \rightarrow T_{n2}\ .\ e)\ e_2 \gios [x \mapsto e_2]e$.
    \item Rule T-IntersectionCast.
    If $\Gamma \iccts e : c_1 \cap \ldots \cap c_n : T_1 \cap \ldots \cap T_n$ then $\Gamma \iccts e : T$.
    By the induction hypothesis, $e$ is either a value, or there is an $e'$ such that $e \gios e'$.
    If $e$ is a value, then by rule E-EvaluateCasts, $e : c_1 \cap \ldots \cap c_n \gios e : cv_1 \cap \ldots \cap cv_n$.
    If there is an $e'$ such that $e \gios e'$, then by rule E-Evaluate, $e : c_1 \cap \ldots \cap c_n \gios e' : c_1 \cap \ldots \cap c_n$.
    \item Rule T-Blame.
    As $\Gamma \iccts \blame{T}{l} : T$ and $\blame{T}{l}$ is a value, it is proved.
\end{itemize}
\end{proof}

\begin{theorem}[Type Safety]
\label{typesafety}
Depends on Lemmas \ref{typepreservation} and \ref{progress}.
Both Type Preservation and Progress hold.
\end{theorem}
\begin{proof}
By Lemma \ref{typepreservation} we have Type Preservation.
By Lemma \ref{progress} we have Progress.
\end{proof}

\begin{theorem}[Blame Theorem]
\label{blame_theorem}
If $\Gamma \iccts e : T$ and $e \gios \blame{T}{l}$ then l is not a safe cast of $e$.
\end{theorem}

\begin{theorem}[Gradual Guarantee]
\label{gradual_guarantee}
If $\Gamma \iccts e_1 : T_1$ and $\Gamma \iccts e_2 : T_2$ and $e_1 \sqsubseteq e_2$ then:
\begin{enumerate}
    \item if $e_2 \gios e_2'$ then $e_1 \icos e_1'$ and $e_1' \sqsubseteq e_2'$.
    \item if $e_1 \gios e_1'$ then either $e_2 \gios e_2'$ and $e_1' \sqsubseteq e_2'$ or $e_2' \gios \blame{T}{l}$.
\end{enumerate}
\end{theorem}

\bibliographystyle{unsrt}
\bibliography{bibliography}

\end{document}
